{
  "version": 3,
  "sources": ["../../@anthropic-ai/sdk/src/error.ts", "../../@anthropic-ai/sdk/src/version.ts", "../../@anthropic-ai/sdk/src/_shims/registry.ts", "../../@anthropic-ai/sdk/src/_shims/MultipartBody.ts", "../../@anthropic-ai/sdk/src/_shims/web-runtime.ts", "../../@anthropic-ai/sdk/_shims/index.mjs", "../../@anthropic-ai/sdk/src/streaming.ts", "../../@anthropic-ai/sdk/src/uploads.ts", "../../@anthropic-ai/sdk/src/core.ts", "../../@anthropic-ai/sdk/src/resource.ts", "../../@anthropic-ai/sdk/src/_vendor/partial-json-parser/parser.ts", "../../@anthropic-ai/sdk/src/lib/PromptCachingBetaMessageStream.ts", "../../@anthropic-ai/sdk/src/resources/beta/prompt-caching/messages.ts", "../../@anthropic-ai/sdk/src/resources/beta/prompt-caching/prompt-caching.ts", "../../@anthropic-ai/sdk/src/resources/beta/beta.ts", "../../@anthropic-ai/sdk/src/resources/completions.ts", "../../@anthropic-ai/sdk/src/lib/MessageStream.ts", "../../@anthropic-ai/sdk/src/resources/messages.ts", "../../@anthropic-ai/sdk/src/index.ts"],
  "sourcesContent": ["// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { castToError, Headers } from \"./core.js\";\r\n\r\nexport class AnthropicError extends Error {}\r\n\r\nexport class APIError extends AnthropicError {\r\n  readonly status: number | undefined;\r\n  readonly headers: Headers | undefined;\r\n  readonly error: Object | undefined;\r\n\r\n  readonly request_id: string | null | undefined;\r\n\r\n  constructor(\r\n    status: number | undefined,\r\n    error: Object | undefined,\r\n    message: string | undefined,\r\n    headers: Headers | undefined,\r\n  ) {\r\n    super(`${APIError.makeMessage(status, error, message)}`);\r\n    this.status = status;\r\n    this.headers = headers;\r\n    this.request_id = headers?.['request-id'];\r\n    this.error = error;\r\n  }\r\n\r\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\r\n    const msg =\r\n      error?.message ?\r\n        typeof error.message === 'string' ?\r\n          error.message\r\n        : JSON.stringify(error.message)\r\n      : error ? JSON.stringify(error)\r\n      : message;\r\n\r\n    if (status && msg) {\r\n      return `${status} ${msg}`;\r\n    }\r\n    if (status) {\r\n      return `${status} status code (no body)`;\r\n    }\r\n    if (msg) {\r\n      return msg;\r\n    }\r\n    return '(no status code or body)';\r\n  }\r\n\r\n  static generate(\r\n    status: number | undefined,\r\n    errorResponse: Object | undefined,\r\n    message: string | undefined,\r\n    headers: Headers | undefined,\r\n  ) {\r\n    if (!status) {\r\n      return new APIConnectionError({ message, cause: castToError(errorResponse) });\r\n    }\r\n\r\n    const error = errorResponse as Record<string, any>;\r\n\r\n    if (status === 400) {\r\n      return new BadRequestError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 401) {\r\n      return new AuthenticationError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 403) {\r\n      return new PermissionDeniedError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 404) {\r\n      return new NotFoundError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 409) {\r\n      return new ConflictError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 422) {\r\n      return new UnprocessableEntityError(status, error, message, headers);\r\n    }\r\n\r\n    if (status === 429) {\r\n      return new RateLimitError(status, error, message, headers);\r\n    }\r\n\r\n    if (status >= 500) {\r\n      return new InternalServerError(status, error, message, headers);\r\n    }\r\n\r\n    return new APIError(status, error, message, headers);\r\n  }\r\n}\r\n\r\nexport class APIUserAbortError extends APIError {\r\n  override readonly status: undefined = undefined;\r\n\r\n  constructor({ message }: { message?: string } = {}) {\r\n    super(undefined, undefined, message || 'Request was aborted.', undefined);\r\n  }\r\n}\r\n\r\nexport class APIConnectionError extends APIError {\r\n  override readonly status: undefined = undefined;\r\n\r\n  constructor({ message, cause }: { message?: string | undefined; cause?: Error | undefined }) {\r\n    super(undefined, undefined, message || 'Connection error.', undefined);\r\n    // in some environments the 'cause' property is already declared\r\n    // @ts-ignore\r\n    if (cause) this.cause = cause;\r\n  }\r\n}\r\n\r\nexport class APIConnectionTimeoutError extends APIConnectionError {\r\n  constructor({ message }: { message?: string } = {}) {\r\n    super({ message: message ?? 'Request timed out.' });\r\n  }\r\n}\r\n\r\nexport class BadRequestError extends APIError {\r\n  override readonly status: 400 = 400;\r\n}\r\n\r\nexport class AuthenticationError extends APIError {\r\n  override readonly status: 401 = 401;\r\n}\r\n\r\nexport class PermissionDeniedError extends APIError {\r\n  override readonly status: 403 = 403;\r\n}\r\n\r\nexport class NotFoundError extends APIError {\r\n  override readonly status: 404 = 404;\r\n}\r\n\r\nexport class ConflictError extends APIError {\r\n  override readonly status: 409 = 409;\r\n}\r\n\r\nexport class UnprocessableEntityError extends APIError {\r\n  override readonly status: 422 = 422;\r\n}\r\n\r\nexport class RateLimitError extends APIError {\r\n  override readonly status: 429 = 429;\r\n}\r\n\r\nexport class InternalServerError extends APIError {}\r\n", "export const VERSION = '0.27.3'; // x-release-please-version\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport { type RequestOptions } from \"../core.js\";\r\n\r\nexport interface Shims {\r\n  kind: string;\r\n  fetch: any;\r\n  Request: any;\r\n  Response: any;\r\n  Headers: any;\r\n  FormData: any;\r\n  Blob: any;\r\n  File: any;\r\n  ReadableStream: any;\r\n  getMultipartRequestOptions: <T = Record<string, unknown>>(\r\n    form: Shims['FormData'],\r\n    opts: RequestOptions<T>,\r\n  ) => Promise<RequestOptions<T>>;\r\n  getDefaultAgent: (url: string) => any;\r\n  fileFromPath:\r\n    | ((path: string, filename?: string, options?: {}) => Promise<Shims['File']>)\r\n    | ((path: string, options?: {}) => Promise<Shims['File']>);\r\n  isFsReadStream: (value: any) => boolean;\r\n}\r\n\r\nexport let auto = false;\r\nexport let kind: Shims['kind'] | undefined = undefined;\r\nexport let fetch: Shims['fetch'] | undefined = undefined;\r\nexport let Request: Shims['Request'] | undefined = undefined;\r\nexport let Response: Shims['Response'] | undefined = undefined;\r\nexport let Headers: Shims['Headers'] | undefined = undefined;\r\nexport let FormData: Shims['FormData'] | undefined = undefined;\r\nexport let Blob: Shims['Blob'] | undefined = undefined;\r\nexport let File: Shims['File'] | undefined = undefined;\r\nexport let ReadableStream: Shims['ReadableStream'] | undefined = undefined;\r\nexport let getMultipartRequestOptions: Shims['getMultipartRequestOptions'] | undefined = undefined;\r\nexport let getDefaultAgent: Shims['getDefaultAgent'] | undefined = undefined;\r\nexport let fileFromPath: Shims['fileFromPath'] | undefined = undefined;\r\nexport let isFsReadStream: Shims['isFsReadStream'] | undefined = undefined;\r\n\r\nexport function setShims(shims: Shims, options: { auto: boolean } = { auto: false }) {\r\n  if (auto) {\r\n    throw new Error(\r\n      `you must \\`import '@anthropic-ai/sdk/shims/${shims.kind}'\\` before importing anything else from @anthropic-ai/sdk`,\r\n    );\r\n  }\r\n  if (kind) {\r\n    throw new Error(\r\n      `can't \\`import '@anthropic-ai/sdk/shims/${shims.kind}'\\` after \\`import '@anthropic-ai/sdk/shims/${kind}'\\``,\r\n    );\r\n  }\r\n  auto = options.auto;\r\n  kind = shims.kind;\r\n  fetch = shims.fetch;\r\n  Request = shims.Request;\r\n  Response = shims.Response;\r\n  Headers = shims.Headers;\r\n  FormData = shims.FormData;\r\n  Blob = shims.Blob;\r\n  File = shims.File;\r\n  ReadableStream = shims.ReadableStream;\r\n  getMultipartRequestOptions = shims.getMultipartRequestOptions;\r\n  getDefaultAgent = shims.getDefaultAgent;\r\n  fileFromPath = shims.fileFromPath;\r\n  isFsReadStream = shims.isFsReadStream;\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nexport class MultipartBody {\r\n  constructor(public body: any) {}\r\n  get [Symbol.toStringTag](): string {\r\n    return 'MultipartBody';\r\n  }\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport { MultipartBody } from \"./MultipartBody.js\";\r\nimport { type RequestOptions } from \"../core.js\";\r\nimport { type Shims } from \"./registry.js\";\r\n\r\nexport function getRuntime({ manuallyImported }: { manuallyImported?: boolean } = {}): Shims {\r\n  const recommendation =\r\n    manuallyImported ?\r\n      `You may need to use polyfills`\r\n    : `Add one of these imports before your first \\`import â€¦ from '@anthropic-ai/sdk'\\`:\r\n- \\`import '@anthropic-ai/sdk/shims/node'\\` (if you're running on Node)\r\n- \\`import '@anthropic-ai/sdk/shims/web'\\` (otherwise)\r\n`;\r\n\r\n  let _fetch, _Request, _Response, _Headers;\r\n  try {\r\n    // @ts-ignore\r\n    _fetch = fetch;\r\n    // @ts-ignore\r\n    _Request = Request;\r\n    // @ts-ignore\r\n    _Response = Response;\r\n    // @ts-ignore\r\n    _Headers = Headers;\r\n  } catch (error) {\r\n    throw new Error(\r\n      `this environment is missing the following Web Fetch API type: ${\r\n        (error as any).message\r\n      }. ${recommendation}`,\r\n    );\r\n  }\r\n\r\n  return {\r\n    kind: 'web',\r\n    fetch: _fetch,\r\n    Request: _Request,\r\n    Response: _Response,\r\n    Headers: _Headers,\r\n    FormData:\r\n      // @ts-ignore\r\n      typeof FormData !== 'undefined' ? FormData : (\r\n        class FormData {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    Blob:\r\n      typeof Blob !== 'undefined' ? Blob : (\r\n        class Blob {\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    File:\r\n      // @ts-ignore\r\n      typeof File !== 'undefined' ? File : (\r\n        class File {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    ReadableStream:\r\n      // @ts-ignore\r\n      typeof ReadableStream !== 'undefined' ? ReadableStream : (\r\n        class ReadableStream {\r\n          // @ts-ignore\r\n          constructor() {\r\n            throw new Error(\r\n              `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`,\r\n            );\r\n          }\r\n        }\r\n      ),\r\n    getMultipartRequestOptions: async <T = Record<string, unknown>>(\r\n      // @ts-ignore\r\n      form: FormData,\r\n      opts: RequestOptions<T>,\r\n    ): Promise<RequestOptions<T>> => ({\r\n      ...opts,\r\n      body: new MultipartBody(form) as any,\r\n    }),\r\n    getDefaultAgent: (url: string) => undefined,\r\n    fileFromPath: () => {\r\n      throw new Error(\r\n        'The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads',\r\n      );\r\n    },\r\n    isFsReadStream: (value: any) => false,\r\n  };\r\n}\r\n", "/**\r\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\r\n */\r\nimport * as shims from './registry.mjs';\r\nimport * as auto from '@anthropic-ai/sdk/_shims/auto/runtime';\r\nif (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\r\nexport * from './registry.mjs';\r\n", "import { ReadableStream, type Response } from \"./_shims/index.js\";\r\nimport { AnthropicError } from \"./error.js\";\r\n\r\nimport { createResponseHeaders } from \"./core.js\";\r\nimport { APIError } from \"./error.js\";\r\n\r\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\r\n\r\nexport type ServerSentEvent = {\r\n  event: string | null;\r\n  data: string;\r\n  raw: string[];\r\n};\r\n\r\nexport class Stream<Item> implements AsyncIterable<Item> {\r\n  controller: AbortController;\r\n\r\n  constructor(\r\n    private iterator: () => AsyncIterator<Item>,\r\n    controller: AbortController,\r\n  ) {\r\n    this.controller = controller;\r\n  }\r\n\r\n  static fromSSEResponse<Item>(response: Response, controller: AbortController) {\r\n    let consumed = false;\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const sse of _iterSSEMessages(response, controller)) {\r\n          if (sse.event === 'completion') {\r\n            try {\r\n              yield JSON.parse(sse.data);\r\n            } catch (e) {\r\n              console.error(`Could not parse message into JSON:`, sse.data);\r\n              console.error(`From chunk:`, sse.raw);\r\n              throw e;\r\n            }\r\n          }\r\n\r\n          if (\r\n            sse.event === 'message_start' ||\r\n            sse.event === 'message_delta' ||\r\n            sse.event === 'message_stop' ||\r\n            sse.event === 'content_block_start' ||\r\n            sse.event === 'content_block_delta' ||\r\n            sse.event === 'content_block_stop'\r\n          ) {\r\n            try {\r\n              yield JSON.parse(sse.data);\r\n            } catch (e) {\r\n              console.error(`Could not parse message into JSON:`, sse.data);\r\n              console.error(`From chunk:`, sse.raw);\r\n              throw e;\r\n            }\r\n          }\r\n\r\n          if (sse.event === 'ping') {\r\n            continue;\r\n          }\r\n\r\n          if (sse.event === 'error') {\r\n            throw APIError.generate(\r\n              undefined,\r\n              `SSE Error: ${sse.data}`,\r\n              sse.data,\r\n              createResponseHeaders(response.headers),\r\n            );\r\n          }\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (e instanceof Error && e.name === 'AbortError') return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  /**\r\n   * Generates a Stream from a newline-separated ReadableStream\r\n   * where each item is a JSON value.\r\n   */\r\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController) {\r\n    let consumed = false;\r\n\r\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\r\n      const lineDecoder = new LineDecoder();\r\n\r\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\r\n      for await (const chunk of iter) {\r\n        for (const line of lineDecoder.decode(chunk)) {\r\n          yield line;\r\n        }\r\n      }\r\n\r\n      for (const line of lineDecoder.flush()) {\r\n        yield line;\r\n      }\r\n    }\r\n\r\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\r\n      if (consumed) {\r\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\r\n      }\r\n      consumed = true;\r\n      let done = false;\r\n      try {\r\n        for await (const line of iterLines()) {\r\n          if (done) continue;\r\n          if (line) yield JSON.parse(line);\r\n        }\r\n        done = true;\r\n      } catch (e) {\r\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\r\n        if (e instanceof Error && e.name === 'AbortError') return;\r\n        throw e;\r\n      } finally {\r\n        // If the user `break`s, abort the ongoing request.\r\n        if (!done) controller.abort();\r\n      }\r\n    }\r\n\r\n    return new Stream(iterator, controller);\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\r\n    return this.iterator();\r\n  }\r\n\r\n  /**\r\n   * Splits the stream into two streams which can be\r\n   * independently read from at different speeds.\r\n   */\r\n  tee(): [Stream<Item>, Stream<Item>] {\r\n    const left: Array<Promise<IteratorResult<Item>>> = [];\r\n    const right: Array<Promise<IteratorResult<Item>>> = [];\r\n    const iterator = this.iterator();\r\n\r\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\r\n      return {\r\n        next: () => {\r\n          if (queue.length === 0) {\r\n            const result = iterator.next();\r\n            left.push(result);\r\n            right.push(result);\r\n          }\r\n          return queue.shift()!;\r\n        },\r\n      };\r\n    };\r\n\r\n    return [\r\n      new Stream(() => teeIterator(left), this.controller),\r\n      new Stream(() => teeIterator(right), this.controller),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Converts this stream to a newline-separated ReadableStream of\r\n   * JSON stringified values in the stream\r\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\r\n   */\r\n  toReadableStream(): ReadableStream {\r\n    const self = this;\r\n    let iter: AsyncIterator<Item>;\r\n    const encoder = new TextEncoder();\r\n\r\n    return new ReadableStream({\r\n      async start() {\r\n        iter = self[Symbol.asyncIterator]();\r\n      },\r\n      async pull(ctrl: any) {\r\n        try {\r\n          const { value, done } = await iter.next();\r\n          if (done) return ctrl.close();\r\n\r\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\r\n\r\n          ctrl.enqueue(bytes);\r\n        } catch (err) {\r\n          ctrl.error(err);\r\n        }\r\n      },\r\n      async cancel() {\r\n        await iter.return?.();\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport async function* _iterSSEMessages(\r\n  response: Response,\r\n  controller: AbortController,\r\n): AsyncGenerator<ServerSentEvent, void, unknown> {\r\n  if (!response.body) {\r\n    controller.abort();\r\n    throw new AnthropicError(`Attempted to iterate over a response with no body`);\r\n  }\r\n\r\n  const sseDecoder = new SSEDecoder();\r\n  const lineDecoder = new LineDecoder();\r\n\r\n  const iter = readableStreamAsyncIterable<Bytes>(response.body);\r\n  for await (const sseChunk of iterSSEChunks(iter)) {\r\n    for (const line of lineDecoder.decode(sseChunk)) {\r\n      const sse = sseDecoder.decode(line);\r\n      if (sse) yield sse;\r\n    }\r\n  }\r\n\r\n  for (const line of lineDecoder.flush()) {\r\n    const sse = sseDecoder.decode(line);\r\n    if (sse) yield sse;\r\n  }\r\n}\r\n\r\n/**\r\n * Given an async iterable iterator, iterates over it and yields full\r\n * SSE chunks, i.e. yields when a double new-line is encountered.\r\n */\r\nasync function* iterSSEChunks(iterator: AsyncIterableIterator<Bytes>): AsyncGenerator<Uint8Array> {\r\n  let data = new Uint8Array();\r\n\r\n  for await (const chunk of iterator) {\r\n    if (chunk == null) {\r\n      continue;\r\n    }\r\n\r\n    const binaryChunk =\r\n      chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\r\n      : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\r\n      : chunk;\r\n\r\n    let newData = new Uint8Array(data.length + binaryChunk.length);\r\n    newData.set(data);\r\n    newData.set(binaryChunk, data.length);\r\n    data = newData;\r\n\r\n    let patternIndex;\r\n    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\r\n      yield data.slice(0, patternIndex);\r\n      data = data.slice(patternIndex);\r\n    }\r\n  }\r\n\r\n  if (data.length > 0) {\r\n    yield data;\r\n  }\r\n}\r\n\r\nfunction findDoubleNewlineIndex(buffer: Uint8Array): number {\r\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\r\n  // and returns the index right after the first occurrence of any pattern,\r\n  // or -1 if none of the patterns are found.\r\n  const newline = 0x0a; // \\n\r\n  const carriage = 0x0d; // \\r\r\n\r\n  for (let i = 0; i < buffer.length - 2; i++) {\r\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\r\n      // \\n\\n\r\n      return i + 2;\r\n    }\r\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\r\n      // \\r\\r\r\n      return i + 2;\r\n    }\r\n    if (\r\n      buffer[i] === carriage &&\r\n      buffer[i + 1] === newline &&\r\n      i + 3 < buffer.length &&\r\n      buffer[i + 2] === carriage &&\r\n      buffer[i + 3] === newline\r\n    ) {\r\n      // \\r\\n\\r\\n\r\n      return i + 4;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nclass SSEDecoder {\r\n  private data: string[];\r\n  private event: string | null;\r\n  private chunks: string[];\r\n\r\n  constructor() {\r\n    this.event = null;\r\n    this.data = [];\r\n    this.chunks = [];\r\n  }\r\n\r\n  decode(line: string) {\r\n    if (line.endsWith('\\r')) {\r\n      line = line.substring(0, line.length - 1);\r\n    }\r\n\r\n    if (!line) {\r\n      // empty line and we didn't previously encounter any messages\r\n      if (!this.event && !this.data.length) return null;\r\n\r\n      const sse: ServerSentEvent = {\r\n        event: this.event,\r\n        data: this.data.join('\\n'),\r\n        raw: this.chunks,\r\n      };\r\n\r\n      this.event = null;\r\n      this.data = [];\r\n      this.chunks = [];\r\n\r\n      return sse;\r\n    }\r\n\r\n    this.chunks.push(line);\r\n\r\n    if (line.startsWith(':')) {\r\n      return null;\r\n    }\r\n\r\n    let [fieldname, _, value] = partition(line, ':');\r\n\r\n    if (value.startsWith(' ')) {\r\n      value = value.substring(1);\r\n    }\r\n\r\n    if (fieldname === 'event') {\r\n      this.event = value;\r\n    } else if (fieldname === 'data') {\r\n      this.data.push(value);\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\r\n * reading lines from text.\r\n *\r\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\r\n */\r\nclass LineDecoder {\r\n  // prettier-ignore\r\n  static NEWLINE_CHARS = new Set(['\\n', '\\r']);\r\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\r\n\r\n  buffer: string[];\r\n  trailingCR: boolean;\r\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\r\n\r\n  constructor() {\r\n    this.buffer = [];\r\n    this.trailingCR = false;\r\n  }\r\n\r\n  decode(chunk: Bytes): string[] {\r\n    let text = this.decodeText(chunk);\r\n\r\n    if (this.trailingCR) {\r\n      text = '\\r' + text;\r\n      this.trailingCR = false;\r\n    }\r\n    if (text.endsWith('\\r')) {\r\n      this.trailingCR = true;\r\n      text = text.slice(0, -1);\r\n    }\r\n\r\n    if (!text) {\r\n      return [];\r\n    }\r\n\r\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\r\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\r\n\r\n    // if there is a trailing new line then the last entry will be an empty\r\n    // string which we don't care about\r\n    if (trailingNewline) {\r\n      lines.pop();\r\n    }\r\n\r\n    if (lines.length === 1 && !trailingNewline) {\r\n      this.buffer.push(lines[0]!);\r\n      return [];\r\n    }\r\n\r\n    if (this.buffer.length > 0) {\r\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\r\n      this.buffer = [];\r\n    }\r\n\r\n    if (!trailingNewline) {\r\n      this.buffer = [lines.pop() || ''];\r\n    }\r\n\r\n    return lines;\r\n  }\r\n\r\n  decodeText(bytes: Bytes): string {\r\n    if (bytes == null) return '';\r\n    if (typeof bytes === 'string') return bytes;\r\n\r\n    // Node:\r\n    if (typeof Buffer !== 'undefined') {\r\n      if (bytes instanceof Buffer) {\r\n        return bytes.toString();\r\n      }\r\n      if (bytes instanceof Uint8Array) {\r\n        return Buffer.from(bytes).toString();\r\n      }\r\n\r\n      throw new AnthropicError(\r\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\r\n      );\r\n    }\r\n\r\n    // Browser\r\n    if (typeof TextDecoder !== 'undefined') {\r\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\r\n        this.textDecoder ??= new TextDecoder('utf8');\r\n        return this.textDecoder.decode(bytes);\r\n      }\r\n\r\n      throw new AnthropicError(\r\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\r\n          (bytes as any).constructor.name\r\n        }) in a web platform. Please report this error.`,\r\n      );\r\n    }\r\n\r\n    throw new AnthropicError(\r\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\r\n    );\r\n  }\r\n\r\n  flush(): string[] {\r\n    if (!this.buffer.length && !this.trailingCR) {\r\n      return [];\r\n    }\r\n\r\n    const lines = [this.buffer.join('')];\r\n    this.buffer = [];\r\n    this.trailingCR = false;\r\n    return lines;\r\n  }\r\n}\r\n\r\n/** This is an internal helper function that's just used for testing */\r\nexport function _decodeChunks(chunks: string[]): string[] {\r\n  const decoder = new LineDecoder();\r\n  const lines: string[] = [];\r\n  for (const chunk of chunks) {\r\n    lines.push(...decoder.decode(chunk));\r\n  }\r\n\r\n  return lines;\r\n}\r\n\r\nfunction partition(str: string, delimiter: string): [string, string, string] {\r\n  const index = str.indexOf(delimiter);\r\n  if (index !== -1) {\r\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\r\n  }\r\n\r\n  return [str, '', ''];\r\n}\r\n\r\n/**\r\n * Most browsers don't yet have async iterable support for ReadableStream,\r\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\r\n *\r\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\r\n */\r\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\r\n  if (stream[Symbol.asyncIterator]) return stream;\r\n\r\n  const reader = stream.getReader();\r\n  return {\r\n    async next() {\r\n      try {\r\n        const result = await reader.read();\r\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\r\n        return result;\r\n      } catch (e) {\r\n        reader.releaseLock(); // release lock when stream becomes errored\r\n        throw e;\r\n      }\r\n    },\r\n    async return() {\r\n      const cancelPromise = reader.cancel();\r\n      reader.releaseLock();\r\n      await cancelPromise;\r\n      return { done: true, value: undefined };\r\n    },\r\n    [Symbol.asyncIterator]() {\r\n      return this;\r\n    },\r\n  };\r\n}\r\n", "import { type RequestOptions } from \"./core.js\";\r\nimport {\r\n  FormData,\r\n  File,\r\n  type Blob,\r\n  type FilePropertyBag,\r\n  getMultipartRequestOptions,\r\n  type FsReadStream,\r\n  isFsReadStream,\r\n} from \"./_shims/index.js\";\r\nimport { MultipartBody } from \"./_shims/MultipartBody.js\";\r\nexport { fileFromPath } from \"./_shims/index.js\";\r\n\r\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\r\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\r\n\r\n/**\r\n * Typically, this is a native \"File\" class.\r\n *\r\n * We provide the {@link toFile} utility to convert a variety of objects\r\n * into the File class.\r\n *\r\n * For convenience, you can also pass a fetch Response, or in Node,\r\n * the result of fs.createReadStream().\r\n */\r\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\r\n\r\n/**\r\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\r\n */\r\nexport interface BlobLike {\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\r\n  readonly size: number;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\r\n  readonly type: string;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\r\n  text(): Promise<string>;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\r\n  slice(start?: number, end?: number): BlobLike;\r\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\r\n}\r\n\r\n/**\r\n * Intended to match web.File, node.File, node-fetch.File, etc.\r\n */\r\nexport interface FileLike extends BlobLike {\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\r\n  readonly lastModified: number;\r\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\r\n  readonly name: string;\r\n}\r\n\r\n/**\r\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\r\n */\r\nexport interface ResponseLike {\r\n  url: string;\r\n  blob(): Promise<BlobLike>;\r\n}\r\n\r\nexport const isResponseLike = (value: any): value is ResponseLike =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.url === 'string' &&\r\n  typeof value.blob === 'function';\r\n\r\nexport const isFileLike = (value: any): value is FileLike =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.name === 'string' &&\r\n  typeof value.lastModified === 'number' &&\r\n  isBlobLike(value);\r\n\r\n/**\r\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\r\n * adds the arrayBuffer() method type because it is available and used at runtime\r\n */\r\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\r\n  value != null &&\r\n  typeof value === 'object' &&\r\n  typeof value.size === 'number' &&\r\n  typeof value.type === 'string' &&\r\n  typeof value.text === 'function' &&\r\n  typeof value.slice === 'function' &&\r\n  typeof value.arrayBuffer === 'function';\r\n\r\nexport const isUploadable = (value: any): value is Uploadable => {\r\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\r\n};\r\n\r\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\r\n\r\n/**\r\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\r\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\r\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\r\n * @param {Object=} options additional properties\r\n * @param {string=} options.type the MIME type of the content\r\n * @param {number=} options.lastModified the last modified timestamp\r\n * @returns a {@link File} with the given properties\r\n */\r\nexport async function toFile(\r\n  value: ToFileInput | PromiseLike<ToFileInput>,\r\n  name?: string | null | undefined,\r\n  options?: FilePropertyBag | undefined,\r\n): Promise<FileLike> {\r\n  // If it's a promise, resolve it.\r\n  value = await value;\r\n\r\n  // If we've been given a `File` we don't need to do anything\r\n  if (isFileLike(value)) {\r\n    return value;\r\n  }\r\n\r\n  if (isResponseLike(value)) {\r\n    const blob = await value.blob();\r\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\r\n\r\n    // we need to convert the `Blob` into an array buffer because the `Blob` class\r\n    // that `node-fetch` defines is incompatible with the web standard which results\r\n    // in `new File` interpreting it as a string instead of binary data.\r\n    const data = isBlobLike(blob) ? [(await blob.arrayBuffer()) as any] : [blob];\r\n\r\n    return new File(data, name, options);\r\n  }\r\n\r\n  const bits = await getBytes(value);\r\n\r\n  name ||= getName(value) ?? 'unknown_file';\r\n\r\n  if (!options?.type) {\r\n    const type = (bits[0] as any)?.type;\r\n    if (typeof type === 'string') {\r\n      options = { ...options, type };\r\n    }\r\n  }\r\n\r\n  return new File(bits, name, options);\r\n}\r\n\r\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\r\n  let parts: Array<BlobPart> = [];\r\n  if (\r\n    typeof value === 'string' ||\r\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\r\n    value instanceof ArrayBuffer\r\n  ) {\r\n    parts.push(value);\r\n  } else if (isBlobLike(value)) {\r\n    parts.push(await value.arrayBuffer());\r\n  } else if (\r\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\r\n  ) {\r\n    for await (const chunk of value) {\r\n      parts.push(chunk as BlobPart); // TODO, consider validating?\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Unexpected data type: ${typeof value}; constructor: ${value?.constructor\r\n        ?.name}; props: ${propsForError(value)}`,\r\n    );\r\n  }\r\n\r\n  return parts;\r\n}\r\n\r\nfunction propsForError(value: any): string {\r\n  const props = Object.getOwnPropertyNames(value);\r\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\r\n}\r\n\r\nfunction getName(value: any): string | undefined {\r\n  return (\r\n    getStringFromMaybeBuffer(value.name) ||\r\n    getStringFromMaybeBuffer(value.filename) ||\r\n    // For fs.ReadStream\r\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\r\n  );\r\n}\r\n\r\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\r\n  if (typeof x === 'string') return x;\r\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\r\n  return undefined;\r\n};\r\n\r\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\r\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\r\n\r\nexport const isMultipartBody = (body: any): body is MultipartBody =>\r\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\r\n\r\n/**\r\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\r\n * Otherwise returns the request as is.\r\n */\r\nexport const maybeMultipartFormRequestOptions = async <T = Record<string, unknown>>(\r\n  opts: RequestOptions<T>,\r\n): Promise<RequestOptions<T | MultipartBody>> => {\r\n  if (!hasUploadableValue(opts.body)) return opts;\r\n\r\n  const form = await createForm(opts.body);\r\n  return getMultipartRequestOptions(form, opts);\r\n};\r\n\r\nexport const multipartFormRequestOptions = async <T = Record<string, unknown>>(\r\n  opts: RequestOptions<T>,\r\n): Promise<RequestOptions<T | MultipartBody>> => {\r\n  const form = await createForm(opts.body);\r\n  return getMultipartRequestOptions(form, opts);\r\n};\r\n\r\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\r\n  const form = new FormData();\r\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\r\n  return form;\r\n};\r\n\r\nconst hasUploadableValue = (value: unknown): boolean => {\r\n  if (isUploadable(value)) return true;\r\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\r\n  if (value && typeof value === 'object') {\r\n    for (const k in value) {\r\n      if (hasUploadableValue((value as any)[k])) return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\r\n  if (value === undefined) return;\r\n  if (value == null) {\r\n    throw new TypeError(\r\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\r\n    );\r\n  }\r\n\r\n  // TODO: make nested formats configurable\r\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n    form.append(key, String(value));\r\n  } else if (isUploadable(value)) {\r\n    const file = await toFile(value);\r\n    form.append(key, file as File);\r\n  } else if (Array.isArray(value)) {\r\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\r\n  } else if (typeof value === 'object') {\r\n    await Promise.all(\r\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\r\n    );\r\n  } else {\r\n    throw new TypeError(\r\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\r\n    );\r\n  }\r\n};\r\n", "import { VERSION } from \"./version.js\";\r\nimport { Stream } from \"./streaming.js\";\r\nimport {\r\n  AnthropicError,\r\n  APIError,\r\n  APIConnectionError,\r\n  APIConnectionTimeoutError,\r\n  APIUserAbortError,\r\n} from \"./error.js\";\r\nimport {\r\n  kind as shimsKind,\r\n  type Readable,\r\n  getDefaultAgent,\r\n  type Agent,\r\n  fetch,\r\n  type RequestInfo,\r\n  type RequestInit,\r\n  type Response,\r\n  type HeadersInit,\r\n} from \"./_shims/index.js\";\r\nexport { type Response };\r\nimport { BlobLike, isBlobLike, isMultipartBody } from \"./uploads.js\";\r\nexport {\r\n  maybeMultipartFormRequestOptions,\r\n  multipartFormRequestOptions,\r\n  createForm,\r\n  type Uploadable,\r\n} from \"./uploads.js\";\r\n\r\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n\r\ntype PromiseOrValue<T> = T | Promise<T>;\r\n\r\ntype APIResponseProps = {\r\n  response: Response;\r\n  options: FinalRequestOptions;\r\n  controller: AbortController;\r\n};\r\n\r\nasync function defaultParseResponse<T>(props: APIResponseProps): Promise<T> {\r\n  const { response } = props;\r\n  if (props.options.stream) {\r\n    debug('response', response.status, response.url, response.headers, response.body);\r\n\r\n    // Note: there is an invariant here that isn't represented in the type system\r\n    // that if you set `stream: true` the response type must also be `Stream<T>`\r\n\r\n    if (props.options.__streamClass) {\r\n      return props.options.__streamClass.fromSSEResponse(response, props.controller) as any;\r\n    }\r\n\r\n    return Stream.fromSSEResponse(response, props.controller) as any;\r\n  }\r\n\r\n  // fetch refuses to read the body when the status code is 204.\r\n  if (response.status === 204) {\r\n    return null as T;\r\n  }\r\n\r\n  if (props.options.__binaryResponse) {\r\n    return response as unknown as T;\r\n  }\r\n\r\n  const contentType = response.headers.get('content-type');\r\n  const isJSON =\r\n    contentType?.includes('application/json') || contentType?.includes('application/vnd.api+json');\r\n  if (isJSON) {\r\n    const json = await response.json();\r\n\r\n    debug('response', response.status, response.url, response.headers, json);\r\n\r\n    return json as T;\r\n  }\r\n\r\n  const text = await response.text();\r\n  debug('response', response.status, response.url, response.headers, text);\r\n\r\n  // TODO handle blob, arraybuffer, other content types, etc.\r\n  return text as unknown as T;\r\n}\r\n\r\n/**\r\n * A subclass of `Promise` providing additional helper methods\r\n * for interacting with the SDK.\r\n */\r\nexport class APIPromise<T> extends Promise<T> {\r\n  private parsedPromise: Promise<T> | undefined;\r\n\r\n  constructor(\r\n    private responsePromise: Promise<APIResponseProps>,\r\n    private parseResponse: (props: APIResponseProps) => PromiseOrValue<T> = defaultParseResponse,\r\n  ) {\r\n    super((resolve) => {\r\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\r\n      // parse the response body; instead .then, .catch, .finally are overridden\r\n      // to parse the response\r\n      resolve(null as any);\r\n    });\r\n  }\r\n\r\n  _thenUnwrap<U>(transform: (data: T) => U): APIPromise<U> {\r\n    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));\r\n  }\r\n\r\n  /**\r\n   * Gets the raw `Response` instance instead of parsing the response\r\n   * data.\r\n   *\r\n   * If you want to parse the response body but still get the `Response`\r\n   * instance, you can use {@link withResponse()}.\r\n   *\r\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\r\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\r\n   * or add one of these imports before your first `import â€¦ from '@anthropic-ai/sdk'`:\r\n   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\r\n   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)\r\n   */\r\n  asResponse(): Promise<Response> {\r\n    return this.responsePromise.then((p) => p.response);\r\n  }\r\n  /**\r\n   * Gets the parsed response data and the raw `Response` instance.\r\n   *\r\n   * If you just want to get the raw `Response` instance without parsing it,\r\n   * you can use {@link asResponse()}.\r\n   *\r\n   *\r\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\r\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\r\n   * or add one of these imports before your first `import â€¦ from '@anthropic-ai/sdk'`:\r\n   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\r\n   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)\r\n   */\r\n  async withResponse(): Promise<{ data: T; response: Response }> {\r\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\r\n    return { data, response };\r\n  }\r\n\r\n  private parse(): Promise<T> {\r\n    if (!this.parsedPromise) {\r\n      this.parsedPromise = this.responsePromise.then(this.parseResponse);\r\n    }\r\n    return this.parsedPromise;\r\n  }\r\n\r\n  override then<TResult1 = T, TResult2 = never>(\r\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\r\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\r\n  ): Promise<TResult1 | TResult2> {\r\n    return this.parse().then(onfulfilled, onrejected);\r\n  }\r\n\r\n  override catch<TResult = never>(\r\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\r\n  ): Promise<T | TResult> {\r\n    return this.parse().catch(onrejected);\r\n  }\r\n\r\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\r\n    return this.parse().finally(onfinally);\r\n  }\r\n}\r\n\r\nexport abstract class APIClient {\r\n  baseURL: string;\r\n  maxRetries: number;\r\n  timeout: number;\r\n  httpAgent: Agent | undefined;\r\n\r\n  private fetch: Fetch;\r\n  protected idempotencyHeader?: string;\r\n\r\n  constructor({\r\n    baseURL,\r\n    maxRetries = 2,\r\n    timeout = 600000, // 10 minutes\r\n    httpAgent,\r\n    fetch: overridenFetch,\r\n  }: {\r\n    baseURL: string;\r\n    maxRetries?: number | undefined;\r\n    timeout: number | undefined;\r\n    httpAgent: Agent | undefined;\r\n    fetch: Fetch | undefined;\r\n  }) {\r\n    this.baseURL = baseURL;\r\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\r\n    this.timeout = validatePositiveInteger('timeout', timeout);\r\n    this.httpAgent = httpAgent;\r\n\r\n    this.fetch = overridenFetch ?? fetch;\r\n  }\r\n\r\n  protected authHeaders(opts: FinalRequestOptions): Headers {\r\n    return {};\r\n  }\r\n\r\n  /**\r\n   * Override this to add your own default headers, for example:\r\n   *\r\n   *  {\r\n   *    ...super.defaultHeaders(),\r\n   *    Authorization: 'Bearer 123',\r\n   *  }\r\n   */\r\n  protected defaultHeaders(opts: FinalRequestOptions): Headers {\r\n    return {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      'User-Agent': this.getUserAgent(),\r\n      ...getPlatformHeaders(),\r\n      ...this.authHeaders(opts),\r\n    };\r\n  }\r\n\r\n  protected abstract defaultQuery(): DefaultQuery | undefined;\r\n\r\n  /**\r\n   * Override this to add your own headers validation:\r\n   */\r\n  protected validateHeaders(headers: Headers, customHeaders: Headers) {}\r\n\r\n  protected defaultIdempotencyKey(): string {\r\n    return `stainless-node-retry-${uuid4()}`;\r\n  }\r\n\r\n  get<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('get', path, opts);\r\n  }\r\n\r\n  post<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('post', path, opts);\r\n  }\r\n\r\n  patch<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('patch', path, opts);\r\n  }\r\n\r\n  put<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('put', path, opts);\r\n  }\r\n\r\n  delete<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\r\n    return this.methodRequest('delete', path, opts);\r\n  }\r\n\r\n  private methodRequest<Req, Rsp>(\r\n    method: HTTPMethod,\r\n    path: string,\r\n    opts?: PromiseOrValue<RequestOptions<Req>>,\r\n  ): APIPromise<Rsp> {\r\n    return this.request(\r\n      Promise.resolve(opts).then(async (opts) => {\r\n        const body =\r\n          opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\r\n          : opts?.body instanceof DataView ? opts.body\r\n          : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\r\n          : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\r\n          : opts?.body;\r\n        return { method, path, ...opts, body };\r\n      }),\r\n    );\r\n  }\r\n\r\n  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\r\n    path: string,\r\n    Page: new (...args: any[]) => PageClass,\r\n    opts?: RequestOptions<any>,\r\n  ): PagePromise<PageClass, Item> {\r\n    return this.requestAPIList(Page, { method: 'get', path, ...opts });\r\n  }\r\n\r\n  private calculateContentLength(body: unknown): string | null {\r\n    if (typeof body === 'string') {\r\n      if (typeof Buffer !== 'undefined') {\r\n        return Buffer.byteLength(body, 'utf8').toString();\r\n      }\r\n\r\n      if (typeof TextEncoder !== 'undefined') {\r\n        const encoder = new TextEncoder();\r\n        const encoded = encoder.encode(body);\r\n        return encoded.length.toString();\r\n      }\r\n    } else if (ArrayBuffer.isView(body)) {\r\n      return body.byteLength.toString();\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  buildRequest<Req>(options: FinalRequestOptions<Req>): { req: RequestInit; url: string; timeout: number } {\r\n    const { method, path, query, headers: headers = {} } = options;\r\n\r\n    const body =\r\n      ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\r\n        options.body\r\n      : isMultipartBody(options.body) ? options.body.body\r\n      : options.body ? JSON.stringify(options.body, null, 2)\r\n      : null;\r\n    const contentLength = this.calculateContentLength(body);\r\n\r\n    const url = this.buildURL(path!, query);\r\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\r\n    const timeout = options.timeout ?? this.timeout;\r\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\r\n    const minAgentTimeout = timeout + 1000;\r\n    if (\r\n      typeof (httpAgent as any)?.options?.timeout === 'number' &&\r\n      minAgentTimeout > ((httpAgent as any).options.timeout ?? 0)\r\n    ) {\r\n      // Allow any given request to bump our agent active socket timeout.\r\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\r\n      // and without mutating agent we would need to create more of them.\r\n      // This tradeoff optimizes for performance.\r\n      (httpAgent as any).options.timeout = minAgentTimeout;\r\n    }\r\n\r\n    if (this.idempotencyHeader && method !== 'get') {\r\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\r\n      headers[this.idempotencyHeader] = options.idempotencyKey;\r\n    }\r\n\r\n    const reqHeaders = this.buildHeaders({ options, headers, contentLength });\r\n\r\n    const req: RequestInit = {\r\n      method,\r\n      ...(body && { body: body as any }),\r\n      headers: reqHeaders,\r\n      ...(httpAgent && { agent: httpAgent }),\r\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\r\n      // not compatible with standard web types\r\n      signal: options.signal ?? null,\r\n    };\r\n\r\n    return { req, url, timeout };\r\n  }\r\n\r\n  private buildHeaders({\r\n    options,\r\n    headers,\r\n    contentLength,\r\n  }: {\r\n    options: FinalRequestOptions;\r\n    headers: Record<string, string | null | undefined>;\r\n    contentLength: string | null | undefined;\r\n  }): Record<string, string> {\r\n    const reqHeaders: Record<string, string> = {};\r\n    if (contentLength) {\r\n      reqHeaders['content-length'] = contentLength;\r\n    }\r\n\r\n    const defaultHeaders = this.defaultHeaders(options);\r\n    applyHeadersMut(reqHeaders, defaultHeaders);\r\n    applyHeadersMut(reqHeaders, headers);\r\n\r\n    // let builtin fetch set the Content-Type for multipart bodies\r\n    if (isMultipartBody(options.body) && shimsKind !== 'node') {\r\n      delete reqHeaders['content-type'];\r\n    }\r\n\r\n    this.validateHeaders(reqHeaders, headers);\r\n\r\n    return reqHeaders;\r\n  }\r\n\r\n  /**\r\n   * Used as a callback for mutating the given `FinalRequestOptions` object.\r\n   */\r\n  protected async prepareOptions(options: FinalRequestOptions): Promise<void> {}\r\n\r\n  /**\r\n   * Used as a callback for mutating the given `RequestInit` object.\r\n   *\r\n   * This is useful for cases where you want to add certain headers based off of\r\n   * the request properties, e.g. `method` or `url`.\r\n   */\r\n  protected async prepareRequest(\r\n    request: RequestInit,\r\n    { url, options }: { url: string; options: FinalRequestOptions },\r\n  ): Promise<void> {}\r\n\r\n  protected parseHeaders(headers: HeadersInit | null | undefined): Record<string, string> {\r\n    return (\r\n      !headers ? {}\r\n      : Symbol.iterator in headers ?\r\n        Object.fromEntries(Array.from(headers as Iterable<string[]>).map((header) => [...header]))\r\n      : { ...headers }\r\n    );\r\n  }\r\n\r\n  protected makeStatusError(\r\n    status: number | undefined,\r\n    error: Object | undefined,\r\n    message: string | undefined,\r\n    headers: Headers | undefined,\r\n  ) {\r\n    return APIError.generate(status, error, message, headers);\r\n  }\r\n\r\n  request<Req, Rsp>(\r\n    options: PromiseOrValue<FinalRequestOptions<Req>>,\r\n    remainingRetries: number | null = null,\r\n  ): APIPromise<Rsp> {\r\n    return new APIPromise(this.makeRequest(options, remainingRetries));\r\n  }\r\n\r\n  private async makeRequest<Req>(\r\n    optionsInput: PromiseOrValue<FinalRequestOptions<Req>>,\r\n    retriesRemaining: number | null,\r\n  ): Promise<APIResponseProps> {\r\n    const options = await optionsInput;\r\n    if (retriesRemaining == null) {\r\n      retriesRemaining = options.maxRetries ?? this.maxRetries;\r\n    }\r\n\r\n    await this.prepareOptions(options);\r\n\r\n    const { req, url, timeout } = this.buildRequest(options);\r\n\r\n    await this.prepareRequest(req, { url, options });\r\n\r\n    debug('request', url, options, req.headers);\r\n\r\n    if (options.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n\r\n    const controller = new AbortController();\r\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\r\n\r\n    if (response instanceof Error) {\r\n      if (options.signal?.aborted) {\r\n        throw new APIUserAbortError();\r\n      }\r\n      if (retriesRemaining) {\r\n        return this.retryRequest(options, retriesRemaining);\r\n      }\r\n      if (response.name === 'AbortError') {\r\n        throw new APIConnectionTimeoutError();\r\n      }\r\n      throw new APIConnectionError({ cause: response });\r\n    }\r\n\r\n    const responseHeaders = createResponseHeaders(response.headers);\r\n\r\n    if (!response.ok) {\r\n      if (retriesRemaining && this.shouldRetry(response)) {\r\n        const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\r\n        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\r\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\r\n      }\r\n\r\n      const errText = await response.text().catch((e) => castToError(e).message);\r\n      const errJSON = safeJSON(errText);\r\n      const errMessage = errJSON ? undefined : errText;\r\n      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\r\n\r\n      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\r\n\r\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\r\n      throw err;\r\n    }\r\n\r\n    return { response, options, controller };\r\n  }\r\n\r\n  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\r\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\r\n    options: FinalRequestOptions,\r\n  ): PagePromise<PageClass, Item> {\r\n    const request = this.makeRequest(options, null);\r\n    return new PagePromise<PageClass, Item>(this, request, Page);\r\n  }\r\n\r\n  buildURL<Req>(path: string, query: Req | null | undefined): string {\r\n    const url =\r\n      isAbsoluteURL(path) ?\r\n        new URL(path)\r\n      : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\r\n\r\n    const defaultQuery = this.defaultQuery();\r\n    if (!isEmptyObj(defaultQuery)) {\r\n      query = { ...defaultQuery, ...query } as Req;\r\n    }\r\n\r\n    if (typeof query === 'object' && query && !Array.isArray(query)) {\r\n      url.search = this.stringifyQuery(query as Record<string, unknown>);\r\n    }\r\n\r\n    return url.toString();\r\n  }\r\n\r\n  protected stringifyQuery(query: Record<string, unknown>): string {\r\n    return Object.entries(query)\r\n      .filter(([_, value]) => typeof value !== 'undefined')\r\n      .map(([key, value]) => {\r\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\r\n          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\r\n        }\r\n        if (value === null) {\r\n          return `${encodeURIComponent(key)}=`;\r\n        }\r\n        throw new AnthropicError(\r\n          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,\r\n        );\r\n      })\r\n      .join('&');\r\n  }\r\n\r\n  async fetchWithTimeout(\r\n    url: RequestInfo,\r\n    init: RequestInit | undefined,\r\n    ms: number,\r\n    controller: AbortController,\r\n  ): Promise<Response> {\r\n    const { signal, ...options } = init || {};\r\n    if (signal) signal.addEventListener('abort', () => controller.abort());\r\n\r\n    const timeout = setTimeout(() => controller.abort(), ms);\r\n\r\n    return (\r\n      this.getRequestClient()\r\n        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\r\n        .fetch.call(undefined, url, { signal: controller.signal as any, ...options })\r\n        .finally(() => {\r\n          clearTimeout(timeout);\r\n        })\r\n    );\r\n  }\r\n\r\n  protected getRequestClient(): RequestClient {\r\n    return { fetch: this.fetch };\r\n  }\r\n\r\n  private shouldRetry(response: Response): boolean {\r\n    // Note this is not a standard header.\r\n    const shouldRetryHeader = response.headers.get('x-should-retry');\r\n\r\n    // If the server explicitly says whether or not to retry, obey.\r\n    if (shouldRetryHeader === 'true') return true;\r\n    if (shouldRetryHeader === 'false') return false;\r\n\r\n    // Retry on request timeouts.\r\n    if (response.status === 408) return true;\r\n\r\n    // Retry on lock timeouts.\r\n    if (response.status === 409) return true;\r\n\r\n    // Retry on rate limits.\r\n    if (response.status === 429) return true;\r\n\r\n    // Retry internal errors.\r\n    if (response.status >= 500) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  private async retryRequest(\r\n    options: FinalRequestOptions,\r\n    retriesRemaining: number,\r\n    responseHeaders?: Headers | undefined,\r\n  ): Promise<APIResponseProps> {\r\n    let timeoutMillis: number | undefined;\r\n\r\n    // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\r\n    const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\r\n    if (retryAfterMillisHeader) {\r\n      const timeoutMs = parseFloat(retryAfterMillisHeader);\r\n      if (!Number.isNaN(timeoutMs)) {\r\n        timeoutMillis = timeoutMs;\r\n      }\r\n    }\r\n\r\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\r\n    const retryAfterHeader = responseHeaders?.['retry-after'];\r\n    if (retryAfterHeader && !timeoutMillis) {\r\n      const timeoutSeconds = parseFloat(retryAfterHeader);\r\n      if (!Number.isNaN(timeoutSeconds)) {\r\n        timeoutMillis = timeoutSeconds * 1000;\r\n      } else {\r\n        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\r\n      }\r\n    }\r\n\r\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\r\n    // just do what it says, but otherwise calculate a default\r\n    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\r\n      const maxRetries = options.maxRetries ?? this.maxRetries;\r\n      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\r\n    }\r\n    await sleep(timeoutMillis);\r\n\r\n    return this.makeRequest(options, retriesRemaining - 1);\r\n  }\r\n\r\n  private calculateDefaultRetryTimeoutMillis(retriesRemaining: number, maxRetries: number): number {\r\n    const initialRetryDelay = 0.5;\r\n    const maxRetryDelay = 8.0;\r\n\r\n    const numRetries = maxRetries - retriesRemaining;\r\n\r\n    // Apply exponential backoff, but not more than the max.\r\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\r\n\r\n    // Apply some jitter, take up to at most 25 percent of the retry time.\r\n    const jitter = 1 - Math.random() * 0.25;\r\n\r\n    return sleepSeconds * jitter * 1000;\r\n  }\r\n\r\n  private getUserAgent(): string {\r\n    return `${this.constructor.name}/JS ${VERSION}`;\r\n  }\r\n}\r\n\r\nexport type PageInfo = { url: URL } | { params: Record<string, unknown> | null };\r\n\r\nexport abstract class AbstractPage<Item> implements AsyncIterable<Item> {\r\n  #client: APIClient;\r\n  protected options: FinalRequestOptions;\r\n\r\n  protected response: Response;\r\n  protected body: unknown;\r\n\r\n  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions) {\r\n    this.#client = client;\r\n    this.options = options;\r\n    this.response = response;\r\n    this.body = body;\r\n  }\r\n\r\n  /**\r\n   * @deprecated Use nextPageInfo instead\r\n   */\r\n  abstract nextPageParams(): Partial<Record<string, unknown>> | null;\r\n  abstract nextPageInfo(): PageInfo | null;\r\n\r\n  abstract getPaginatedItems(): Item[];\r\n\r\n  hasNextPage(): boolean {\r\n    const items = this.getPaginatedItems();\r\n    if (!items.length) return false;\r\n    return this.nextPageInfo() != null;\r\n  }\r\n\r\n  async getNextPage(): Promise<this> {\r\n    const nextInfo = this.nextPageInfo();\r\n    if (!nextInfo) {\r\n      throw new AnthropicError(\r\n        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',\r\n      );\r\n    }\r\n    const nextOptions = { ...this.options };\r\n    if ('params' in nextInfo && typeof nextOptions.query === 'object') {\r\n      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\r\n    } else if ('url' in nextInfo) {\r\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\r\n      for (const [key, value] of params) {\r\n        nextInfo.url.searchParams.set(key, value as any);\r\n      }\r\n      nextOptions.query = undefined;\r\n      nextOptions.path = nextInfo.url.toString();\r\n    }\r\n    return await this.#client.requestAPIList(this.constructor as any, nextOptions);\r\n  }\r\n\r\n  async *iterPages() {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let page: AbstractPage<Item> = this;\r\n    yield page;\r\n    while (page.hasNextPage()) {\r\n      page = await page.getNextPage();\r\n      yield page;\r\n    }\r\n  }\r\n\r\n  async *[Symbol.asyncIterator]() {\r\n    for await (const page of this.iterPages()) {\r\n      for (const item of page.getPaginatedItems()) {\r\n        yield item;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\r\n *\r\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\r\n *\r\n *    for await (const item of client.items.list()) {\r\n *      console.log(item)\r\n *    }\r\n */\r\nexport class PagePromise<\r\n    PageClass extends AbstractPage<Item>,\r\n    Item = ReturnType<PageClass['getPaginatedItems']>[number],\r\n  >\r\n  extends APIPromise<PageClass>\r\n  implements AsyncIterable<Item>\r\n{\r\n  constructor(\r\n    client: APIClient,\r\n    request: Promise<APIResponseProps>,\r\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\r\n  ) {\r\n    super(\r\n      request,\r\n      async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Allow auto-paginating iteration on an unawaited list call, eg:\r\n   *\r\n   *    for await (const item of client.items.list()) {\r\n   *      console.log(item)\r\n   *    }\r\n   */\r\n  async *[Symbol.asyncIterator]() {\r\n    const page = await this;\r\n    for await (const item of page) {\r\n      yield item;\r\n    }\r\n  }\r\n}\r\n\r\nexport const createResponseHeaders = (\r\n  headers: Awaited<ReturnType<Fetch>>['headers'],\r\n): Record<string, string> => {\r\n  return new Proxy(\r\n    Object.fromEntries(\r\n      // @ts-ignore\r\n      headers.entries(),\r\n    ),\r\n    {\r\n      get(target, name) {\r\n        const key = name.toString();\r\n        return target[key.toLowerCase()] || target[key];\r\n      },\r\n    },\r\n  );\r\n};\r\n\r\ntype HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';\r\n\r\nexport type RequestClient = { fetch: Fetch };\r\nexport type Headers = Record<string, string | null | undefined>;\r\nexport type DefaultQuery = Record<string, string | undefined>;\r\nexport type KeysEnum<T> = { [P in keyof Required<T>]: true };\r\n\r\nexport type RequestOptions<\r\n  Req = unknown | Record<string, unknown> | Readable | BlobLike | ArrayBufferView | ArrayBuffer,\r\n> = {\r\n  method?: HTTPMethod;\r\n  path?: string;\r\n  query?: Req | undefined;\r\n  body?: Req | null | undefined;\r\n  headers?: Headers | undefined;\r\n\r\n  maxRetries?: number;\r\n  stream?: boolean | undefined;\r\n  timeout?: number;\r\n  httpAgent?: Agent;\r\n  signal?: AbortSignal | undefined | null;\r\n  idempotencyKey?: string;\r\n\r\n  __binaryRequest?: boolean | undefined;\r\n  __binaryResponse?: boolean | undefined;\r\n  __streamClass?: typeof Stream;\r\n};\r\n\r\n// This is required so that we can determine if a given object matches the RequestOptions\r\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\r\n// compiler such that any missing / extraneous keys will cause an error.\r\nconst requestOptionsKeys: KeysEnum<RequestOptions> = {\r\n  method: true,\r\n  path: true,\r\n  query: true,\r\n  body: true,\r\n  headers: true,\r\n\r\n  maxRetries: true,\r\n  stream: true,\r\n  timeout: true,\r\n  httpAgent: true,\r\n  signal: true,\r\n  idempotencyKey: true,\r\n\r\n  __binaryRequest: true,\r\n  __binaryResponse: true,\r\n  __streamClass: true,\r\n};\r\n\r\nexport const isRequestOptions = (obj: unknown): obj is RequestOptions => {\r\n  return (\r\n    typeof obj === 'object' &&\r\n    obj !== null &&\r\n    !isEmptyObj(obj) &&\r\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\r\n  );\r\n};\r\n\r\nexport type FinalRequestOptions<Req = unknown | Record<string, unknown> | Readable | DataView> =\r\n  RequestOptions<Req> & {\r\n    method: HTTPMethod;\r\n    path: string;\r\n  };\r\n\r\ndeclare const Deno: any;\r\ndeclare const EdgeRuntime: any;\r\ntype Arch = 'x32' | 'x64' | 'arm' | 'arm64' | `other:${string}` | 'unknown';\r\ntype PlatformName =\r\n  | 'MacOS'\r\n  | 'Linux'\r\n  | 'Windows'\r\n  | 'FreeBSD'\r\n  | 'OpenBSD'\r\n  | 'iOS'\r\n  | 'Android'\r\n  | `Other:${string}`\r\n  | 'Unknown';\r\ntype Browser = 'ie' | 'edge' | 'chrome' | 'firefox' | 'safari';\r\ntype PlatformProperties = {\r\n  'X-Stainless-Lang': 'js';\r\n  'X-Stainless-Package-Version': string;\r\n  'X-Stainless-OS': PlatformName;\r\n  'X-Stainless-Arch': Arch;\r\n  'X-Stainless-Runtime': 'node' | 'deno' | 'edge' | `browser:${Browser}` | 'unknown';\r\n  'X-Stainless-Runtime-Version': string;\r\n};\r\nconst getPlatformProperties = (): PlatformProperties => {\r\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\r\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\r\n      'X-Stainless-Runtime': 'deno',\r\n      'X-Stainless-Runtime-Version':\r\n        typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\r\n    };\r\n  }\r\n  if (typeof EdgeRuntime !== 'undefined') {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': 'Unknown',\r\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\r\n      'X-Stainless-Runtime': 'edge',\r\n      'X-Stainless-Runtime-Version': process.version,\r\n    };\r\n  }\r\n  // Check if Node.js\r\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': normalizePlatform(process.platform),\r\n      'X-Stainless-Arch': normalizeArch(process.arch),\r\n      'X-Stainless-Runtime': 'node',\r\n      'X-Stainless-Runtime-Version': process.version,\r\n    };\r\n  }\r\n\r\n  const browserInfo = getBrowserInfo();\r\n  if (browserInfo) {\r\n    return {\r\n      'X-Stainless-Lang': 'js',\r\n      'X-Stainless-Package-Version': VERSION,\r\n      'X-Stainless-OS': 'Unknown',\r\n      'X-Stainless-Arch': 'unknown',\r\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\r\n      'X-Stainless-Runtime-Version': browserInfo.version,\r\n    };\r\n  }\r\n\r\n  // TODO add support for Cloudflare workers, etc.\r\n  return {\r\n    'X-Stainless-Lang': 'js',\r\n    'X-Stainless-Package-Version': VERSION,\r\n    'X-Stainless-OS': 'Unknown',\r\n    'X-Stainless-Arch': 'unknown',\r\n    'X-Stainless-Runtime': 'unknown',\r\n    'X-Stainless-Runtime-Version': 'unknown',\r\n  };\r\n};\r\n\r\ntype BrowserInfo = {\r\n  browser: Browser;\r\n  version: string;\r\n};\r\n\r\ndeclare const navigator: { userAgent: string } | undefined;\r\n\r\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\r\nfunction getBrowserInfo(): BrowserInfo | null {\r\n  if (typeof navigator === 'undefined' || !navigator) {\r\n    return null;\r\n  }\r\n\r\n  // NOTE: The order matters here!\r\n  const browserPatterns = [\r\n    { key: 'edge' as const, pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'ie' as const, pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'ie' as const, pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'chrome' as const, pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'firefox' as const, pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\r\n    { key: 'safari' as const, pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\r\n  ];\r\n\r\n  // Find the FIRST matching browser\r\n  for (const { key, pattern } of browserPatterns) {\r\n    const match = pattern.exec(navigator.userAgent);\r\n    if (match) {\r\n      const major = match[1] || 0;\r\n      const minor = match[2] || 0;\r\n      const patch = match[3] || 0;\r\n\r\n      return { browser: key, version: `${major}.${minor}.${patch}` };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nconst normalizeArch = (arch: string): Arch => {\r\n  // Node docs:\r\n  // - https://nodejs.org/api/process.html#processarch\r\n  // Deno docs:\r\n  // - https://doc.deno.land/deno/stable/~/Deno.build\r\n  if (arch === 'x32') return 'x32';\r\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\r\n  if (arch === 'arm') return 'arm';\r\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\r\n  if (arch) return `other:${arch}`;\r\n  return 'unknown';\r\n};\r\n\r\nconst normalizePlatform = (platform: string): PlatformName => {\r\n  // Node platforms:\r\n  // - https://nodejs.org/api/process.html#processplatform\r\n  // Deno platforms:\r\n  // - https://doc.deno.land/deno/stable/~/Deno.build\r\n  // - https://github.com/denoland/deno/issues/14799\r\n\r\n  platform = platform.toLowerCase();\r\n\r\n  // NOTE: this iOS check is untested and may not work\r\n  // Node does not work natively on IOS, there is a fork at\r\n  // https://github.com/nodejs-mobile/nodejs-mobile\r\n  // however it is unknown at the time of writing how to detect if it is running\r\n  if (platform.includes('ios')) return 'iOS';\r\n  if (platform === 'android') return 'Android';\r\n  if (platform === 'darwin') return 'MacOS';\r\n  if (platform === 'win32') return 'Windows';\r\n  if (platform === 'freebsd') return 'FreeBSD';\r\n  if (platform === 'openbsd') return 'OpenBSD';\r\n  if (platform === 'linux') return 'Linux';\r\n  if (platform) return `Other:${platform}`;\r\n  return 'Unknown';\r\n};\r\n\r\nlet _platformHeaders: PlatformProperties;\r\nconst getPlatformHeaders = () => {\r\n  return (_platformHeaders ??= getPlatformProperties());\r\n};\r\n\r\nexport const safeJSON = (text: string) => {\r\n  try {\r\n    return JSON.parse(text);\r\n  } catch (err) {\r\n    return undefined;\r\n  }\r\n};\r\n\r\n// https://stackoverflow.com/a/19709846\r\nconst startsWithSchemeRegexp = new RegExp('^(?:[a-z]+:)?//', 'i');\r\nconst isAbsoluteURL = (url: string): boolean => {\r\n  return startsWithSchemeRegexp.test(url);\r\n};\r\n\r\nexport const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\r\n\r\nconst validatePositiveInteger = (name: string, n: unknown): number => {\r\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\r\n    throw new AnthropicError(`${name} must be an integer`);\r\n  }\r\n  if (n < 0) {\r\n    throw new AnthropicError(`${name} must be a positive integer`);\r\n  }\r\n  return n;\r\n};\r\n\r\nexport const castToError = (err: any): Error => {\r\n  if (err instanceof Error) return err;\r\n  return new Error(err);\r\n};\r\n\r\nexport const ensurePresent = <T>(value: T | null | undefined): T => {\r\n  if (value == null) throw new AnthropicError(`Expected a value to be given but received ${value} instead.`);\r\n  return value;\r\n};\r\n\r\n/**\r\n * Read an environment variable.\r\n *\r\n * Trims beginning and trailing whitespace.\r\n *\r\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\r\n */\r\nexport const readEnv = (env: string): string | undefined => {\r\n  if (typeof process !== 'undefined') {\r\n    return process.env?.[env]?.trim() ?? undefined;\r\n  }\r\n  if (typeof Deno !== 'undefined') {\r\n    return Deno.env?.get?.(env)?.trim();\r\n  }\r\n  return undefined;\r\n};\r\n\r\nexport const coerceInteger = (value: unknown): number => {\r\n  if (typeof value === 'number') return Math.round(value);\r\n  if (typeof value === 'string') return parseInt(value, 10);\r\n\r\n  throw new AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\r\n};\r\n\r\nexport const coerceFloat = (value: unknown): number => {\r\n  if (typeof value === 'number') return value;\r\n  if (typeof value === 'string') return parseFloat(value);\r\n\r\n  throw new AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\r\n};\r\n\r\nexport const coerceBoolean = (value: unknown): boolean => {\r\n  if (typeof value === 'boolean') return value;\r\n  if (typeof value === 'string') return value === 'true';\r\n  return Boolean(value);\r\n};\r\n\r\nexport const maybeCoerceInteger = (value: unknown): number | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceInteger(value);\r\n};\r\n\r\nexport const maybeCoerceFloat = (value: unknown): number | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceFloat(value);\r\n};\r\n\r\nexport const maybeCoerceBoolean = (value: unknown): boolean | undefined => {\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  return coerceBoolean(value);\r\n};\r\n\r\n// https://stackoverflow.com/a/34491287\r\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\r\n  if (!obj) return true;\r\n  for (const _k in obj) return false;\r\n  return true;\r\n}\r\n\r\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\r\nexport function hasOwn(obj: Object, key: string): boolean {\r\n  return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\n\r\n/**\r\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\r\n * using lower-case for all properties,\r\n * ignoring any keys with undefined values,\r\n * and deleting any keys with null values.\r\n */\r\nfunction applyHeadersMut(targetHeaders: Headers, newHeaders: Headers): void {\r\n  for (const k in newHeaders) {\r\n    if (!hasOwn(newHeaders, k)) continue;\r\n    const lowerKey = k.toLowerCase();\r\n    if (!lowerKey) continue;\r\n\r\n    const val = newHeaders[k];\r\n\r\n    if (val === null) {\r\n      delete targetHeaders[lowerKey];\r\n    } else if (val !== undefined) {\r\n      targetHeaders[lowerKey] = val;\r\n    }\r\n  }\r\n}\r\n\r\nexport function debug(action: string, ...args: any[]) {\r\n  if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\r\n    console.log(`Anthropic:DEBUG:${action}`, ...args);\r\n  }\r\n}\r\n\r\n/**\r\n * https://stackoverflow.com/a/2117523\r\n */\r\nconst uuid4 = () => {\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    const r = (Math.random() * 16) | 0;\r\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n    return v.toString(16);\r\n  });\r\n};\r\n\r\nexport const isRunningInBrowser = () => {\r\n  return (\r\n    // @ts-ignore\r\n    typeof window !== 'undefined' &&\r\n    // @ts-ignore\r\n    typeof window.document !== 'undefined' &&\r\n    // @ts-ignore\r\n    typeof navigator !== 'undefined'\r\n  );\r\n};\r\n\r\nexport interface HeadersProtocol {\r\n  get: (header: string) => string | null | undefined;\r\n}\r\nexport type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;\r\n\r\nexport const isHeadersProtocol = (headers: any): headers is HeadersProtocol => {\r\n  return typeof headers?.get === 'function';\r\n};\r\n\r\nexport const getRequiredHeader = (headers: HeadersLike, header: string): string => {\r\n  const lowerCasedHeader = header.toLowerCase();\r\n  if (isHeadersProtocol(headers)) {\r\n    // to deal with the case where the header looks like Stainless-Event-Id\r\n    const intercapsHeader =\r\n      header[0]?.toUpperCase() +\r\n      header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\r\n    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\r\n      const value = headers.get(key);\r\n      if (value) {\r\n        return value;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const [key, value] of Object.entries(headers)) {\r\n    if (key.toLowerCase() === lowerCasedHeader) {\r\n      if (Array.isArray(value)) {\r\n        if (value.length <= 1) return value[0];\r\n        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\r\n        return value[0];\r\n      }\r\n      return value;\r\n    }\r\n  }\r\n\r\n  throw new Error(`Could not find ${header} header`);\r\n};\r\n\r\n/**\r\n * Encodes a string to Base64 format.\r\n */\r\nexport const toBase64 = (str: string | null | undefined): string => {\r\n  if (!str) return '';\r\n  if (typeof Buffer !== 'undefined') {\r\n    return Buffer.from(str).toString('base64');\r\n  }\r\n\r\n  if (typeof btoa !== 'undefined') {\r\n    return btoa(str);\r\n  }\r\n\r\n  throw new AnthropicError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\r\n};\r\n\r\nexport function isObj(obj: unknown): obj is Record<string, unknown> {\r\n  return obj != null && typeof obj === 'object' && !Array.isArray(obj);\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport * as Core from \"./core.js\";\r\n\r\nexport class APIResource {\r\n  protected _client: Core.APIClient;\r\n\r\n  constructor(client: Core.APIClient) {\r\n    this._client = client;\r\n  }\r\n}\r\n", "type Token = {\r\n  type: string;\r\n  value: string;\r\n};\r\n\r\nconst tokenize = (input: string): Token[] => {\r\n    let current = 0;\r\n    let tokens: Token[] = [];\r\n\r\n    while (current < input.length) {\r\n      let char = input[current];\r\n\r\n      if (char === '\\\\') {\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === '{') {\r\n        tokens.push({\r\n          type: 'brace',\r\n          value: '{',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === '}') {\r\n        tokens.push({\r\n          type: 'brace',\r\n          value: '}',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === '[') {\r\n        tokens.push({\r\n          type: 'paren',\r\n          value: '[',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === ']') {\r\n        tokens.push({\r\n          type: 'paren',\r\n          value: ']',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === ':') {\r\n        tokens.push({\r\n          type: 'separator',\r\n          value: ':',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === ',') {\r\n        tokens.push({\r\n          type: 'delimiter',\r\n          value: ',',\r\n        });\r\n\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      if (char === '\"') {\r\n        let value = '';\r\n        let danglingQuote = false;\r\n\r\n        char = input[++current];\r\n\r\n        while (char !== '\"') {\r\n          if (current === input.length) {\r\n            danglingQuote = true;\r\n            break;\r\n          }\r\n\r\n          if (char === '\\\\') {\r\n            current++;\r\n            if (current === input.length) {\r\n              danglingQuote = true;\r\n              break;\r\n            }\r\n            value += char + input[current];\r\n            char = input[++current];\r\n          } else {\r\n            value += char;\r\n            char = input[++current];\r\n          }\r\n        }\r\n\r\n        char = input[++current];\r\n\r\n        if (!danglingQuote) {\r\n          tokens.push({\r\n            type: 'string',\r\n            value,\r\n          });\r\n        }\r\n        continue;\r\n      }\r\n\r\n      let WHITESPACE = /\\s/;\r\n      if (char && WHITESPACE.test(char)) {\r\n        current++;\r\n        continue;\r\n      }\r\n\r\n      let NUMBERS = /[0-9]/;\r\n      if ((char && NUMBERS.test(char)) || char === '-' || char === '.') {\r\n        let value = '';\r\n\r\n        if (char === '-') {\r\n          value += char;\r\n          char = input[++current];\r\n        }\r\n\r\n        while ((char && NUMBERS.test(char)) || char === '.') {\r\n          value += char;\r\n          char = input[++current];\r\n        }\r\n\r\n        tokens.push({\r\n          type: 'number',\r\n          value,\r\n        });\r\n        continue;\r\n      }\r\n\r\n      let LETTERS = /[a-z]/i;\r\n      if (char && LETTERS.test(char)) {\r\n        let value = '';\r\n\r\n        while (char && LETTERS.test(char)) {\r\n          if (current === input.length) {\r\n            break;\r\n          }\r\n          value += char;\r\n          char = input[++current];\r\n        }\r\n\r\n        if (value == 'true' || value == 'false' || value === 'null') {\r\n          tokens.push({\r\n            type: 'name',\r\n            value,\r\n          });\r\n        } else {\r\n          // unknown token, e.g. `nul` which isn't quite `null`\r\n          current++;\r\n          continue;\r\n        }\r\n        continue;\r\n      }\r\n\r\n      current++;\r\n    }\r\n\r\n    return tokens;\r\n  },\r\n  strip = (tokens: Token[]): Token[] => {\r\n    if (tokens.length === 0) {\r\n      return tokens;\r\n    }\r\n\r\n    let lastToken = tokens[tokens.length - 1]!;\r\n\r\n    switch (lastToken.type) {\r\n      case 'separator':\r\n        tokens = tokens.slice(0, tokens.length - 1);\r\n        return strip(tokens);\r\n        break;\r\n      case 'number':\r\n        let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];\r\n        if (lastCharacterOfLastToken === '.' || lastCharacterOfLastToken === '-') {\r\n          tokens = tokens.slice(0, tokens.length - 1);\r\n          return strip(tokens);\r\n        }\r\n      case 'string':\r\n        let tokenBeforeTheLastToken = tokens[tokens.length - 2];\r\n        if (tokenBeforeTheLastToken?.type === 'delimiter') {\r\n          tokens = tokens.slice(0, tokens.length - 1);\r\n          return strip(tokens);\r\n        } else if (tokenBeforeTheLastToken?.type === 'brace' && tokenBeforeTheLastToken.value === '{') {\r\n          tokens = tokens.slice(0, tokens.length - 1);\r\n          return strip(tokens);\r\n        }\r\n        break;\r\n      case 'delimiter':\r\n        tokens = tokens.slice(0, tokens.length - 1);\r\n        return strip(tokens);\r\n        break;\r\n    }\r\n\r\n    return tokens;\r\n  },\r\n  unstrip = (tokens: Token[]): Token[] => {\r\n    let tail: string[] = [];\r\n\r\n    tokens.map((token) => {\r\n      if (token.type === 'brace') {\r\n        if (token.value === '{') {\r\n          tail.push('}');\r\n        } else {\r\n          tail.splice(tail.lastIndexOf('}'), 1);\r\n        }\r\n      }\r\n      if (token.type === 'paren') {\r\n        if (token.value === '[') {\r\n          tail.push(']');\r\n        } else {\r\n          tail.splice(tail.lastIndexOf(']'), 1);\r\n        }\r\n      }\r\n    });\r\n\r\n    if (tail.length > 0) {\r\n      tail.reverse().map((item) => {\r\n        if (item === '}') {\r\n          tokens.push({\r\n            type: 'brace',\r\n            value: '}',\r\n          });\r\n        } else if (item === ']') {\r\n          tokens.push({\r\n            type: 'paren',\r\n            value: ']',\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    return tokens;\r\n  },\r\n  generate = (tokens: Token[]): string => {\r\n    let output = '';\r\n\r\n    tokens.map((token) => {\r\n      switch (token.type) {\r\n        case 'string':\r\n          output += '\"' + token.value + '\"';\r\n          break;\r\n        default:\r\n          output += token.value;\r\n          break;\r\n      }\r\n    });\r\n\r\n    return output;\r\n  },\r\n  partialParse = (input: string): unknown => JSON.parse(generate(unstrip(strip(tokenize(input)))));\r\n\r\nexport { partialParse };\r\n", "import * as Core from \"../core.js\";\r\nimport { AnthropicError, APIUserAbortError } from \"../error.js\";\r\nimport { type ContentBlock, type TextBlock } from \"../resources/messages.js\";\r\nimport {\r\n  Messages,\r\n  type PromptCachingBetaMessage,\r\n  type RawPromptCachingBetaMessageStreamEvent,\r\n  type PromptCachingBetaMessageParam,\r\n  type MessageCreateParams,\r\n  type MessageCreateParamsBase,\r\n} from \"../resources/beta/prompt-caching/messages.js\";\r\nimport { type ReadableStream } from \"../_shims/index.js\";\r\nimport { Stream } from \"../streaming.js\";\r\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.js\";\r\n\r\nexport interface PromptCachingBetaMessageStreamEvents {\r\n  connect: () => void;\r\n  streamEvent: (event: RawPromptCachingBetaMessageStreamEvent, snapshot: PromptCachingBetaMessage) => void;\r\n  text: (textDelta: string, textSnapshot: string) => void;\r\n  inputJson: (partialJson: string, jsonSnapshot: unknown) => void;\r\n  message: (message: PromptCachingBetaMessage) => void;\r\n  contentBlock: (content: ContentBlock) => void;\r\n  finalPromptCachingBetaMessage: (message: PromptCachingBetaMessage) => void;\r\n  error: (error: AnthropicError) => void;\r\n  abort: (error: APIUserAbortError) => void;\r\n  end: () => void;\r\n}\r\n\r\ntype PromptCachingBetaMessageStreamEventListeners<Event extends keyof PromptCachingBetaMessageStreamEvents> =\r\n  {\r\n    listener: PromptCachingBetaMessageStreamEvents[Event];\r\n    once?: boolean;\r\n  }[];\r\n\r\nconst JSON_BUF_PROPERTY = '__json_buf';\r\n\r\nexport class PromptCachingBetaMessageStream implements AsyncIterable<RawPromptCachingBetaMessageStreamEvent> {\r\n  messages: PromptCachingBetaMessageParam[] = [];\r\n  receivedMessages: PromptCachingBetaMessage[] = [];\r\n  #currentMessageSnapshot: PromptCachingBetaMessage | undefined;\r\n\r\n  controller: AbortController = new AbortController();\r\n\r\n  #connectedPromise: Promise<void>;\r\n  #resolveConnectedPromise: () => void = () => {};\r\n  #rejectConnectedPromise: (error: AnthropicError) => void = () => {};\r\n\r\n  #endPromise: Promise<void>;\r\n  #resolveEndPromise: () => void = () => {};\r\n  #rejectEndPromise: (error: AnthropicError) => void = () => {};\r\n\r\n  #listeners: {\r\n    [Event in keyof PromptCachingBetaMessageStreamEvents]?: PromptCachingBetaMessageStreamEventListeners<Event>;\r\n  } = {};\r\n\r\n  #ended = false;\r\n  #errored = false;\r\n  #aborted = false;\r\n  #catchingPromiseCreated = false;\r\n\r\n  constructor() {\r\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\r\n      this.#resolveConnectedPromise = resolve;\r\n      this.#rejectConnectedPromise = reject;\r\n    });\r\n\r\n    this.#endPromise = new Promise<void>((resolve, reject) => {\r\n      this.#resolveEndPromise = resolve;\r\n      this.#rejectEndPromise = reject;\r\n    });\r\n\r\n    // Don't let these promises cause unhandled rejection errors.\r\n    // we will manually cause an unhandled rejection error later\r\n    // if the user hasn't registered any error listener or called\r\n    // any promise-returning method.\r\n    this.#connectedPromise.catch(() => {});\r\n    this.#endPromise.catch(() => {});\r\n  }\r\n\r\n  /**\r\n   * Intended for use on the frontend, consuming a stream produced with\r\n   * `.toReadableStream()` on the backend.\r\n   *\r\n   * Note that messages sent to the model do not appear in `.on('message')`\r\n   * in this context.\r\n   */\r\n  static fromReadableStream(stream: ReadableStream): PromptCachingBetaMessageStream {\r\n    const runner = new PromptCachingBetaMessageStream();\r\n    runner._run(() => runner._fromReadableStream(stream));\r\n    return runner;\r\n  }\r\n\r\n  static createMessage(\r\n    messages: Messages,\r\n    params: MessageCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): PromptCachingBetaMessageStream {\r\n    const runner = new PromptCachingBetaMessageStream();\r\n    for (const message of params.messages) {\r\n      runner._addPromptCachingBetaMessageParam(message);\r\n    }\r\n    runner._run(() =>\r\n      runner._createPromptCachingBetaMessage(\r\n        messages,\r\n        { ...params, stream: true },\r\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\r\n      ),\r\n    );\r\n    return runner;\r\n  }\r\n\r\n  protected _run(executor: () => Promise<any>) {\r\n    executor().then(() => {\r\n      this._emitFinal();\r\n      this._emit('end');\r\n    }, this.#handleError);\r\n  }\r\n\r\n  protected _addPromptCachingBetaMessageParam(message: PromptCachingBetaMessageParam) {\r\n    this.messages.push(message);\r\n  }\r\n\r\n  protected _addPromptCachingBetaMessage(message: PromptCachingBetaMessage, emit = true) {\r\n    this.receivedMessages.push(message);\r\n    if (emit) {\r\n      this._emit('message', message);\r\n    }\r\n  }\r\n\r\n  protected async _createPromptCachingBetaMessage(\r\n    messages: Messages,\r\n    params: MessageCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<void> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n    const stream = await messages.create(\r\n      { ...params, stream: true },\r\n      { ...options, signal: this.controller.signal },\r\n    );\r\n    this._connected();\r\n    for await (const event of stream) {\r\n      this.#addStreamEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    this.#endRequest();\r\n  }\r\n\r\n  protected _connected() {\r\n    if (this.ended) return;\r\n    this.#resolveConnectedPromise();\r\n    this._emit('connect');\r\n  }\r\n\r\n  get ended(): boolean {\r\n    return this.#ended;\r\n  }\r\n\r\n  get errored(): boolean {\r\n    return this.#errored;\r\n  }\r\n\r\n  get aborted(): boolean {\r\n    return this.#aborted;\r\n  }\r\n\r\n  abort() {\r\n    this.controller.abort();\r\n  }\r\n\r\n  /**\r\n   * Adds the listener function to the end of the listeners array for the event.\r\n   * No checks are made to see if the listener has already been added. Multiple calls passing\r\n   * the same combination of event and listener will result in the listener being added, and\r\n   * called, multiple times.\r\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\r\n   */\r\n  on<Event extends keyof PromptCachingBetaMessageStreamEvents>(\r\n    event: Event,\r\n    listener: PromptCachingBetaMessageStreamEvents[Event],\r\n  ): this {\r\n    const listeners: PromptCachingBetaMessageStreamEventListeners<Event> =\r\n      this.#listeners[event] || (this.#listeners[event] = []);\r\n    listeners.push({ listener });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes the specified listener from the listener array for the event.\r\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\r\n   * listener has been added multiple times to the listener array for the specified event, then\r\n   * off() must be called multiple times to remove each instance.\r\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\r\n   */\r\n  off<Event extends keyof PromptCachingBetaMessageStreamEvents>(\r\n    event: Event,\r\n    listener: PromptCachingBetaMessageStreamEvents[Event],\r\n  ): this {\r\n    const listeners = this.#listeners[event];\r\n    if (!listeners) return this;\r\n    const index = listeners.findIndex((l) => l.listener === listener);\r\n    if (index >= 0) listeners.splice(index, 1);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a one-time listener function for the event. The next time the event is triggered,\r\n   * this listener is removed and then invoked.\r\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\r\n   */\r\n  once<Event extends keyof PromptCachingBetaMessageStreamEvents>(\r\n    event: Event,\r\n    listener: PromptCachingBetaMessageStreamEvents[Event],\r\n  ): this {\r\n    const listeners: PromptCachingBetaMessageStreamEventListeners<Event> =\r\n      this.#listeners[event] || (this.#listeners[event] = []);\r\n    listeners.push({ listener, once: true });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\r\n   * the event is triggered, instead of calling a listener callback.\r\n   * @returns a Promise that resolves the next time given event is triggered,\r\n   * or rejects if an error is emitted.  (If you request the 'error' event,\r\n   * returns a promise that resolves with the error).\r\n   *\r\n   * Example:\r\n   *\r\n   *   const message = await stream.emitted('message') // rejects if the stream errors\r\n   */\r\n  emitted<Event extends keyof PromptCachingBetaMessageStreamEvents>(\r\n    event: Event,\r\n  ): Promise<\r\n    Parameters<PromptCachingBetaMessageStreamEvents[Event]> extends [infer Param] ? Param\r\n    : Parameters<PromptCachingBetaMessageStreamEvents[Event]> extends [] ? void\r\n    : Parameters<PromptCachingBetaMessageStreamEvents[Event]>\r\n  > {\r\n    return new Promise((resolve, reject) => {\r\n      this.#catchingPromiseCreated = true;\r\n      if (event !== 'error') this.once('error', reject);\r\n      this.once(event, resolve as any);\r\n    });\r\n  }\r\n\r\n  async done(): Promise<void> {\r\n    this.#catchingPromiseCreated = true;\r\n    await this.#endPromise;\r\n  }\r\n\r\n  get currentMessage(): PromptCachingBetaMessage | undefined {\r\n    return this.#currentMessageSnapshot;\r\n  }\r\n\r\n  #getFinalMessage(): PromptCachingBetaMessage {\r\n    if (this.receivedMessages.length === 0) {\r\n      throw new AnthropicError(\r\n        'stream ended without producing a PromptCachingBetaMessage with role=assistant',\r\n      );\r\n    }\r\n    return this.receivedMessages.at(-1)!;\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage response,\r\n   * or rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.\r\n   */\r\n  async finalMessage(): Promise<PromptCachingBetaMessage> {\r\n    await this.done();\r\n    return this.#getFinalMessage();\r\n  }\r\n\r\n  #getFinalText(): string {\r\n    if (this.receivedMessages.length === 0) {\r\n      throw new AnthropicError(\r\n        'stream ended without producing a PromptCachingBetaMessage with role=assistant',\r\n      );\r\n    }\r\n    const textBlocks = this.receivedMessages\r\n      .at(-1)!\r\n      .content.filter((block): block is TextBlock => block.type === 'text')\r\n      .map((block) => block.text);\r\n    if (textBlocks.length === 0) {\r\n      throw new AnthropicError('stream ended without producing a content block with type=text');\r\n    }\r\n    return textBlocks.join(' ');\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage's text response, concatenated\r\n   * together if there are more than one text blocks.\r\n   * Rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.\r\n   */\r\n  async finalText(): Promise<string> {\r\n    await this.done();\r\n    return this.#getFinalText();\r\n  }\r\n\r\n  #handleError = (error: unknown) => {\r\n    this.#errored = true;\r\n    if (error instanceof Error && error.name === 'AbortError') {\r\n      error = new APIUserAbortError();\r\n    }\r\n    if (error instanceof APIUserAbortError) {\r\n      this.#aborted = true;\r\n      return this._emit('abort', error);\r\n    }\r\n    if (error instanceof AnthropicError) {\r\n      return this._emit('error', error);\r\n    }\r\n    if (error instanceof Error) {\r\n      const anthropicError: AnthropicError = new AnthropicError(error.message);\r\n      // @ts-ignore\r\n      anthropicError.cause = error;\r\n      return this._emit('error', anthropicError);\r\n    }\r\n    return this._emit('error', new AnthropicError(String(error)));\r\n  };\r\n\r\n  protected _emit<Event extends keyof PromptCachingBetaMessageStreamEvents>(\r\n    event: Event,\r\n    ...args: Parameters<PromptCachingBetaMessageStreamEvents[Event]>\r\n  ) {\r\n    // make sure we don't emit any PromptCachingBetaMessageStreamEvents after end\r\n    if (this.#ended) return;\r\n\r\n    if (event === 'end') {\r\n      this.#ended = true;\r\n      this.#resolveEndPromise();\r\n    }\r\n\r\n    const listeners: PromptCachingBetaMessageStreamEventListeners<Event> | undefined = this.#listeners[event];\r\n    if (listeners) {\r\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\r\n      listeners.forEach(({ listener }: any) => listener(...args));\r\n    }\r\n\r\n    if (event === 'abort') {\r\n      const error = args[0] as APIUserAbortError;\r\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\r\n        Promise.reject(error);\r\n      }\r\n      this.#rejectConnectedPromise(error);\r\n      this.#rejectEndPromise(error);\r\n      this._emit('end');\r\n      return;\r\n    }\r\n\r\n    if (event === 'error') {\r\n      // NOTE: _emit('error', error) should only be called from #handleError().\r\n\r\n      const error = args[0] as AnthropicError;\r\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\r\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\r\n        // If you are seeing stack traces here, make sure to handle errors via either:\r\n        // - runner.on('error', () => ...)\r\n        // - await runner.done()\r\n        // - await runner.final...()\r\n        // - etc.\r\n        Promise.reject(error);\r\n      }\r\n      this.#rejectConnectedPromise(error);\r\n      this.#rejectEndPromise(error);\r\n      this._emit('end');\r\n    }\r\n  }\r\n\r\n  protected _emitFinal() {\r\n    const finalPromptCachingBetaMessage = this.receivedMessages.at(-1);\r\n    if (finalPromptCachingBetaMessage) {\r\n      this._emit('finalPromptCachingBetaMessage', this.#getFinalMessage());\r\n    }\r\n  }\r\n\r\n  #beginRequest() {\r\n    if (this.ended) return;\r\n    this.#currentMessageSnapshot = undefined;\r\n  }\r\n  #addStreamEvent(event: RawPromptCachingBetaMessageStreamEvent) {\r\n    if (this.ended) return;\r\n    const messageSnapshot = this.#accumulateMessage(event);\r\n    this._emit('streamEvent', event, messageSnapshot);\r\n\r\n    switch (event.type) {\r\n      case 'content_block_delta': {\r\n        const content = messageSnapshot.content.at(-1)!;\r\n        if (event.delta.type === 'text_delta' && content.type === 'text') {\r\n          this._emit('text', event.delta.text, content.text || '');\r\n        } else if (event.delta.type === 'input_json_delta' && content.type === 'tool_use') {\r\n          if (content.input) {\r\n            this._emit('inputJson', event.delta.partial_json, content.input);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case 'message_stop': {\r\n        this._addPromptCachingBetaMessageParam(messageSnapshot);\r\n        this._addPromptCachingBetaMessage(messageSnapshot, true);\r\n        break;\r\n      }\r\n      case 'content_block_stop': {\r\n        this._emit('contentBlock', messageSnapshot.content.at(-1)!);\r\n        break;\r\n      }\r\n      case 'message_start': {\r\n        this.#currentMessageSnapshot = messageSnapshot;\r\n        break;\r\n      }\r\n      case 'content_block_start':\r\n      case 'message_delta':\r\n        break;\r\n    }\r\n  }\r\n  #endRequest(): PromptCachingBetaMessage {\r\n    if (this.ended) {\r\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\r\n    }\r\n    const snapshot = this.#currentMessageSnapshot;\r\n    if (!snapshot) {\r\n      throw new AnthropicError(`request ended without sending any chunks`);\r\n    }\r\n    this.#currentMessageSnapshot = undefined;\r\n    return snapshot;\r\n  }\r\n\r\n  protected async _fromReadableStream(\r\n    readableStream: ReadableStream,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<void> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n    this._connected();\r\n    const stream = Stream.fromReadableStream<RawPromptCachingBetaMessageStreamEvent>(\r\n      readableStream,\r\n      this.controller,\r\n    );\r\n    for await (const event of stream) {\r\n      this.#addStreamEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    this.#endRequest();\r\n  }\r\n\r\n  /**\r\n   * Mutates this.#currentPromptCachingBetaMessage with the current event. Handling the accumulation of multiple messages\r\n   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple\r\n   * messages.\r\n   */\r\n  #accumulateMessage(event: RawPromptCachingBetaMessageStreamEvent): PromptCachingBetaMessage {\r\n    let snapshot = this.#currentMessageSnapshot;\r\n\r\n    if (event.type === 'message_start') {\r\n      if (snapshot) {\r\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\r\n      }\r\n      return event.message;\r\n    }\r\n\r\n    if (!snapshot) {\r\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\r\n    }\r\n\r\n    switch (event.type) {\r\n      case 'message_stop':\r\n        return snapshot;\r\n      case 'message_delta':\r\n        snapshot.stop_reason = event.delta.stop_reason;\r\n        snapshot.stop_sequence = event.delta.stop_sequence;\r\n        snapshot.usage.output_tokens = event.usage.output_tokens;\r\n        return snapshot;\r\n      case 'content_block_start':\r\n        snapshot.content.push(event.content_block);\r\n        return snapshot;\r\n      case 'content_block_delta': {\r\n        const snapshotContent = snapshot.content.at(event.index);\r\n        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {\r\n          snapshotContent.text += event.delta.text;\r\n        } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {\r\n          // we need to keep track of the raw JSON string as well so that we can\r\n          // re-parse it for each delta, for now we just store it as an untyped\r\n          // non-enumerable property on the snapshot\r\n          let jsonBuf = (snapshotContent as any)[JSON_BUF_PROPERTY] || '';\r\n          jsonBuf += event.delta.partial_json;\r\n\r\n          Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\r\n            value: jsonBuf,\r\n            enumerable: false,\r\n            writable: true,\r\n          });\r\n\r\n          if (jsonBuf) {\r\n            snapshotContent.input = partialParse(jsonBuf);\r\n          }\r\n        }\r\n        return snapshot;\r\n      }\r\n      case 'content_block_stop':\r\n        return snapshot;\r\n    }\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<RawPromptCachingBetaMessageStreamEvent> {\r\n    const pushQueue: RawPromptCachingBetaMessageStreamEvent[] = [];\r\n    const readQueue: {\r\n      resolve: (chunk: RawPromptCachingBetaMessageStreamEvent | undefined) => void;\r\n      reject: (error: unknown) => void;\r\n    }[] = [];\r\n    let done = false;\r\n\r\n    this.on('streamEvent', (event) => {\r\n      const reader = readQueue.shift();\r\n      if (reader) {\r\n        reader.resolve(event);\r\n      } else {\r\n        pushQueue.push(event);\r\n      }\r\n    });\r\n\r\n    this.on('end', () => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.resolve(undefined);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('abort', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('error', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    return {\r\n      next: async (): Promise<IteratorResult<RawPromptCachingBetaMessageStreamEvent>> => {\r\n        if (!pushQueue.length) {\r\n          if (done) {\r\n            return { value: undefined, done: true };\r\n          }\r\n          return new Promise<RawPromptCachingBetaMessageStreamEvent | undefined>((resolve, reject) =>\r\n            readQueue.push({ resolve, reject }),\r\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\r\n        }\r\n        const chunk = pushQueue.shift()!;\r\n        return { value: chunk, done: false };\r\n      },\r\n      return: async () => {\r\n        this.abort();\r\n        return { value: undefined, done: true };\r\n      },\r\n    };\r\n  }\r\n\r\n  toReadableStream(): ReadableStream {\r\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\r\n    return stream.toReadableStream();\r\n  }\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../../resource.js\";\r\nimport { APIPromise } from \"../../../core.js\";\r\nimport * as Core from \"../../../core.js\";\r\nimport * as PromptCachingMessagesAPI from \"./messages.js\";\r\nimport * as MessagesAPI from \"../../messages.js\";\r\nimport { Stream } from \"../../../streaming.js\";\r\nimport { PromptCachingBetaMessageStream } from \"../../../lib/PromptCachingBetaMessageStream.js\";\r\n\r\nexport class Messages extends APIResource {\r\n  /**\r\n   * Create a Message.\r\n   *\r\n   * Send a structured list of input messages with text and/or image content, and the\r\n   * model will generate the next message in the conversation.\r\n   *\r\n   * The Messages API can be used for either single queries or stateless multi-turn\r\n   * conversations.\r\n   */\r\n  create(\r\n    body: MessageCreateParamsNonStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<PromptCachingBetaMessage>;\r\n  create(\r\n    body: MessageCreateParamsStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<RawPromptCachingBetaMessageStreamEvent>>;\r\n  create(\r\n    body: MessageCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<RawPromptCachingBetaMessageStreamEvent> | PromptCachingBetaMessage>;\r\n  create(\r\n    body: MessageCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<PromptCachingBetaMessage> | APIPromise<Stream<RawPromptCachingBetaMessageStreamEvent>> {\r\n    return this._client.post('/v1/messages?beta=prompt_caching', {\r\n      body,\r\n      timeout: (this._client as any)._options.timeout ?? 600000,\r\n      ...options,\r\n      headers: { 'anthropic-beta': 'prompt-caching-2024-07-31', ...options?.headers },\r\n      stream: body.stream ?? false,\r\n    }) as APIPromise<PromptCachingBetaMessage> | APIPromise<Stream<RawPromptCachingBetaMessageStreamEvent>>;\r\n  }\r\n\r\n  /**\r\n   * Create a Message stream\r\n   */\r\n  stream(body: MessageStreamParams, options?: Core.RequestOptions): PromptCachingBetaMessageStream {\r\n    return PromptCachingBetaMessageStream.createMessage(this, body, options);\r\n  }\r\n}\r\n\r\nexport type MessageStreamParams = MessageCreateParamsBase;\r\n\r\nexport interface PromptCachingBetaCacheControlEphemeral {\r\n  type: 'ephemeral';\r\n}\r\n\r\nexport interface PromptCachingBetaImageBlockParam {\r\n  source: PromptCachingBetaImageBlockParam.Source;\r\n\r\n  type: 'image';\r\n\r\n  cache_control?: PromptCachingBetaCacheControlEphemeral | null;\r\n}\r\n\r\nexport namespace PromptCachingBetaImageBlockParam {\r\n  export interface Source {\r\n    data: string;\r\n\r\n    media_type: 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp';\r\n\r\n    type: 'base64';\r\n  }\r\n}\r\n\r\nexport interface PromptCachingBetaMessage {\r\n  /**\r\n   * Unique object identifier.\r\n   *\r\n   * The format and length of IDs may change over time.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * Content generated by the model.\r\n   *\r\n   * This is an array of content blocks, each of which has a `type` that determines\r\n   * its shape.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```json\r\n   * [{ \"type\": \"text\", \"text\": \"Hi, I'm Claude.\" }]\r\n   * ```\r\n   *\r\n   * If the request input `messages` ended with an `assistant` turn, then the\r\n   * response `content` will continue directly from that last turn. You can use this\r\n   * to constrain the model's output.\r\n   *\r\n   * For example, if the input `messages` were:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Then the response `content` might be:\r\n   *\r\n   * ```json\r\n   * [{ \"type\": \"text\", \"text\": \"B)\" }]\r\n   * ```\r\n   */\r\n  content: Array<MessagesAPI.ContentBlock>;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * Conversational role of the generated message.\r\n   *\r\n   * This will always be `\"assistant\"`.\r\n   */\r\n  role: 'assistant';\r\n\r\n  /**\r\n   * The reason that we stopped.\r\n   *\r\n   * This may be one the following values:\r\n   *\r\n   * - `\"end_turn\"`: the model reached a natural stopping point\r\n   * - `\"max_tokens\"`: we exceeded the requested `max_tokens` or the model's maximum\r\n   * - `\"stop_sequence\"`: one of your provided custom `stop_sequences` was generated\r\n   * - `\"tool_use\"`: the model invoked one or more tools\r\n   *\r\n   * In non-streaming mode this value is always non-null. In streaming mode, it is\r\n   * null in the `message_start` event and non-null otherwise.\r\n   */\r\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use' | null;\r\n\r\n  /**\r\n   * Which custom stop sequence was generated, if any.\r\n   *\r\n   * This value will be a non-null string if one of your custom stop sequences was\r\n   * generated.\r\n   */\r\n  stop_sequence: string | null;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Messages, this is always `\"message\"`.\r\n   */\r\n  type: 'message';\r\n\r\n  /**\r\n   * Billing and rate-limit usage.\r\n   *\r\n   * Anthropic's API bills and rate-limits by token counts, as tokens represent the\r\n   * underlying cost to our systems.\r\n   *\r\n   * Under the hood, the API transforms requests into a format suitable for the\r\n   * model. The model's output then goes through a parsing stage before becoming an\r\n   * API response. As a result, the token counts in `usage` will not match one-to-one\r\n   * with the exact visible content of an API request or response.\r\n   *\r\n   * For example, `output_tokens` will be non-zero, even for an empty string response\r\n   * from Claude.\r\n   */\r\n  usage: PromptCachingBetaUsage;\r\n}\r\n\r\nexport interface PromptCachingBetaMessageParam {\r\n  content:\r\n    | string\r\n    | Array<\r\n        | PromptCachingBetaTextBlockParam\r\n        | PromptCachingBetaImageBlockParam\r\n        | PromptCachingBetaToolUseBlockParam\r\n        | PromptCachingBetaToolResultBlockParam\r\n      >;\r\n\r\n  role: 'user' | 'assistant';\r\n}\r\n\r\nexport interface PromptCachingBetaTextBlockParam {\r\n  text: string;\r\n\r\n  type: 'text';\r\n\r\n  cache_control?: PromptCachingBetaCacheControlEphemeral | null;\r\n}\r\n\r\nexport interface PromptCachingBetaTool {\r\n  /**\r\n   * [JSON schema](https://json-schema.org/) for this tool's input.\r\n   *\r\n   * This defines the shape of the `input` that your tool accepts and that the model\r\n   * will produce.\r\n   */\r\n  input_schema: PromptCachingBetaTool.InputSchema;\r\n\r\n  name: string;\r\n\r\n  cache_control?: PromptCachingBetaCacheControlEphemeral | null;\r\n\r\n  /**\r\n   * Description of what this tool does.\r\n   *\r\n   * Tool descriptions should be as detailed as possible. The more information that\r\n   * the model has about what the tool is and how to use it, the better it will\r\n   * perform. You can use natural language descriptions to reinforce important\r\n   * aspects of the tool input JSON schema.\r\n   */\r\n  description?: string;\r\n}\r\n\r\nexport namespace PromptCachingBetaTool {\r\n  /**\r\n   * [JSON schema](https://json-schema.org/) for this tool's input.\r\n   *\r\n   * This defines the shape of the `input` that your tool accepts and that the model\r\n   * will produce.\r\n   */\r\n  export interface InputSchema {\r\n    type: 'object';\r\n\r\n    properties?: unknown | null;\r\n    [k: string]: unknown;\r\n  }\r\n}\r\n\r\nexport interface PromptCachingBetaToolResultBlockParam {\r\n  tool_use_id: string;\r\n\r\n  type: 'tool_result';\r\n\r\n  cache_control?: PromptCachingBetaCacheControlEphemeral | null;\r\n\r\n  content?: string | Array<PromptCachingBetaTextBlockParam | PromptCachingBetaImageBlockParam>;\r\n\r\n  is_error?: boolean;\r\n}\r\n\r\nexport interface PromptCachingBetaToolUseBlockParam {\r\n  id: string;\r\n\r\n  input: unknown;\r\n\r\n  name: string;\r\n\r\n  type: 'tool_use';\r\n\r\n  cache_control?: PromptCachingBetaCacheControlEphemeral | null;\r\n}\r\n\r\nexport interface PromptCachingBetaUsage {\r\n  /**\r\n   * The number of input tokens used to create the cache entry.\r\n   */\r\n  cache_creation_input_tokens: number | null;\r\n\r\n  /**\r\n   * The number of input tokens read from the cache.\r\n   */\r\n  cache_read_input_tokens: number | null;\r\n\r\n  /**\r\n   * The number of input tokens which were used.\r\n   */\r\n  input_tokens: number;\r\n\r\n  /**\r\n   * The number of output tokens which were used.\r\n   */\r\n  output_tokens: number;\r\n}\r\n\r\nexport interface RawPromptCachingBetaMessageStartEvent {\r\n  message: PromptCachingBetaMessage;\r\n\r\n  type: 'message_start';\r\n}\r\n\r\nexport type RawPromptCachingBetaMessageStreamEvent =\r\n  | RawPromptCachingBetaMessageStartEvent\r\n  | MessagesAPI.RawMessageDeltaEvent\r\n  | MessagesAPI.RawMessageStopEvent\r\n  | MessagesAPI.RawContentBlockStartEvent\r\n  | MessagesAPI.RawContentBlockDeltaEvent\r\n  | MessagesAPI.RawContentBlockStopEvent;\r\n\r\nexport type MessageCreateParams = MessageCreateParamsNonStreaming | MessageCreateParamsStreaming;\r\n\r\nexport interface MessageCreateParamsBase {\r\n  /**\r\n   * The maximum number of tokens to generate before stopping.\r\n   *\r\n   * Note that our models may stop _before_ reaching this maximum. This parameter\r\n   * only specifies the absolute maximum number of tokens to generate.\r\n   *\r\n   * Different models have different maximum values for this parameter. See\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for details.\r\n   */\r\n  max_tokens: number;\r\n\r\n  /**\r\n   * Input messages.\r\n   *\r\n   * Our models are trained to operate on alternating `user` and `assistant`\r\n   * conversational turns. When creating a new `Message`, you specify the prior\r\n   * conversational turns with the `messages` parameter, and the model then generates\r\n   * the next `Message` in the conversation.\r\n   *\r\n   * Each input message must be an object with a `role` and `content`. You can\r\n   * specify a single `user`-role message, or you can include multiple `user` and\r\n   * `assistant` messages. The first message must always use the `user` role.\r\n   *\r\n   * If the final message uses the `assistant` role, the response content will\r\n   * continue immediately from the content in that message. This can be used to\r\n   * constrain part of the model's response.\r\n   *\r\n   * Example with a single `user` message:\r\n   *\r\n   * ```json\r\n   * [{ \"role\": \"user\", \"content\": \"Hello, Claude\" }]\r\n   * ```\r\n   *\r\n   * Example with multiple conversational turns:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   { \"role\": \"user\", \"content\": \"Hello there.\" },\r\n   *   { \"role\": \"assistant\", \"content\": \"Hi, I'm Claude. How can I help you?\" },\r\n   *   { \"role\": \"user\", \"content\": \"Can you explain LLMs in plain English?\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Example with a partially-filled response from Claude:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Each input message `content` may be either a single `string` or an array of\r\n   * content blocks, where each block has a specific `type`. Using a `string` for\r\n   * `content` is shorthand for an array of one content block of type `\"text\"`. The\r\n   * following input messages are equivalent:\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": \"Hello, Claude\" }\r\n   * ```\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": [{ \"type\": \"text\", \"text\": \"Hello, Claude\" }] }\r\n   * ```\r\n   *\r\n   * Starting with Claude 3 models, you can also send image content blocks:\r\n   *\r\n   * ```json\r\n   * {\r\n   *   \"role\": \"user\",\r\n   *   \"content\": [\r\n   *     {\r\n   *       \"type\": \"image\",\r\n   *       \"source\": {\r\n   *         \"type\": \"base64\",\r\n   *         \"media_type\": \"image/jpeg\",\r\n   *         \"data\": \"/9j/4AAQSkZJRg...\"\r\n   *       }\r\n   *     },\r\n   *     { \"type\": \"text\", \"text\": \"What is in this image?\" }\r\n   *   ]\r\n   * }\r\n   * ```\r\n   *\r\n   * We currently support the `base64` source type for images, and the `image/jpeg`,\r\n   * `image/png`, `image/gif`, and `image/webp` media types.\r\n   *\r\n   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for\r\n   * more input examples.\r\n   *\r\n   * Note that if you want to include a\r\n   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use\r\n   * the top-level `system` parameter â€” there is no `\"system\"` role for input\r\n   * messages in the Messages API.\r\n   */\r\n  messages: Array<PromptCachingBetaMessageParam>;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * An object describing metadata about the request.\r\n   */\r\n  metadata?: MessageCreateParams.Metadata;\r\n\r\n  /**\r\n   * Custom text sequences that will cause the model to stop generating.\r\n   *\r\n   * Our models will normally stop when they have naturally completed their turn,\r\n   * which will result in a response `stop_reason` of `\"end_turn\"`.\r\n   *\r\n   * If you want the model to stop generating when it encounters custom strings of\r\n   * text, you can use the `stop_sequences` parameter. If the model encounters one of\r\n   * the custom sequences, the response `stop_reason` value will be `\"stop_sequence\"`\r\n   * and the response `stop_sequence` value will contain the matched stop sequence.\r\n   */\r\n  stop_sequences?: Array<string>;\r\n\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream?: boolean;\r\n\r\n  /**\r\n   * System prompt.\r\n   *\r\n   * A system prompt is a way of providing context and instructions to Claude, such\r\n   * as specifying a particular goal or role. See our\r\n   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).\r\n   */\r\n  system?: string | Array<PromptCachingBetaTextBlockParam>;\r\n\r\n  /**\r\n   * Amount of randomness injected into the response.\r\n   *\r\n   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`\r\n   * for analytical / multiple choice, and closer to `1.0` for creative and\r\n   * generative tasks.\r\n   *\r\n   * Note that even with `temperature` of `0.0`, the results will not be fully\r\n   * deterministic.\r\n   */\r\n  temperature?: number;\r\n\r\n  /**\r\n   * How the model should use the provided tools. The model can use a specific tool,\r\n   * any available tool, or decide by itself.\r\n   */\r\n  tool_choice?:\r\n    | MessageCreateParams.ToolChoiceAuto\r\n    | MessageCreateParams.ToolChoiceAny\r\n    | MessageCreateParams.ToolChoiceTool;\r\n\r\n  /**\r\n   * Definitions of tools that the model may use.\r\n   *\r\n   * If you include `tools` in your API request, the model may return `tool_use`\r\n   * content blocks that represent the model's use of those tools. You can then run\r\n   * those tools using the tool input generated by the model and then optionally\r\n   * return results back to the model using `tool_result` content blocks.\r\n   *\r\n   * Each tool definition includes:\r\n   *\r\n   * - `name`: Name of the tool.\r\n   * - `description`: Optional, but strongly-recommended description of the tool.\r\n   * - `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input`\r\n   *   shape that the model will produce in `tool_use` output content blocks.\r\n   *\r\n   * For example, if you defined `tools` as:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"description\": \"Get the current stock price for a given ticker symbol.\",\r\n   *     \"input_schema\": {\r\n   *       \"type\": \"object\",\r\n   *       \"properties\": {\r\n   *         \"ticker\": {\r\n   *           \"type\": \"string\",\r\n   *           \"description\": \"The stock ticker symbol, e.g. AAPL for Apple Inc.\"\r\n   *         }\r\n   *       },\r\n   *       \"required\": [\"ticker\"]\r\n   *     }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * And then asked the model \"What's the S&P 500 at today?\", the model might produce\r\n   * `tool_use` content blocks in the response like this:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_use\",\r\n   *     \"id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"input\": { \"ticker\": \"^GSPC\" }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * You might then run your `get_stock_price` tool with `{\"ticker\": \"^GSPC\"}` as an\r\n   * input, and return the following back to the model in a subsequent `user`\r\n   * message:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_result\",\r\n   *     \"tool_use_id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"content\": \"259.75 USD\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Tools can be used for workflows that include running client-side tools and\r\n   * functions, or more generally whenever you want the model to produce a particular\r\n   * JSON structure of output.\r\n   *\r\n   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.\r\n   */\r\n  tools?: Array<PromptCachingBetaTool>;\r\n\r\n  /**\r\n   * Only sample from the top K options for each subsequent token.\r\n   *\r\n   * Used to remove \"long tail\" low probability responses.\r\n   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_k?: number;\r\n\r\n  /**\r\n   * Use nucleus sampling.\r\n   *\r\n   * In nucleus sampling, we compute the cumulative distribution over all the options\r\n   * for each subsequent token in decreasing probability order and cut it off once it\r\n   * reaches a particular probability specified by `top_p`. You should either alter\r\n   * `temperature` or `top_p`, but not both.\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_p?: number;\r\n}\r\n\r\nexport namespace MessageCreateParams {\r\n  /**\r\n   * An object describing metadata about the request.\r\n   */\r\n  export interface Metadata {\r\n    /**\r\n     * An external identifier for the user who is associated with the request.\r\n     *\r\n     * This should be a uuid, hash value, or other opaque identifier. Anthropic may use\r\n     * this id to help detect abuse. Do not include any identifying information such as\r\n     * name, email address, or phone number.\r\n     */\r\n    user_id?: string | null;\r\n  }\r\n\r\n  /**\r\n   * The model will automatically decide whether to use tools.\r\n   */\r\n  export interface ToolChoiceAuto {\r\n    type: 'auto';\r\n  }\r\n\r\n  /**\r\n   * The model will use any available tools.\r\n   */\r\n  export interface ToolChoiceAny {\r\n    type: 'any';\r\n  }\r\n\r\n  /**\r\n   * The model will use the specified tool with `tool_choice.name`.\r\n   */\r\n  export interface ToolChoiceTool {\r\n    /**\r\n     * The name of the tool to use.\r\n     */\r\n    name: string;\r\n\r\n    type: 'tool';\r\n  }\r\n\r\n  export type MessageCreateParamsNonStreaming = PromptCachingMessagesAPI.MessageCreateParamsNonStreaming;\r\n  export type MessageCreateParamsStreaming = PromptCachingMessagesAPI.MessageCreateParamsStreaming;\r\n}\r\n\r\nexport interface MessageCreateParamsNonStreaming extends MessageCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream?: false;\r\n}\r\n\r\nexport interface MessageCreateParamsStreaming extends MessageCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream: true;\r\n}\r\n\r\nexport namespace Messages {\r\n  export import PromptCachingBetaCacheControlEphemeral = PromptCachingMessagesAPI.PromptCachingBetaCacheControlEphemeral;\r\n  export import PromptCachingBetaImageBlockParam = PromptCachingMessagesAPI.PromptCachingBetaImageBlockParam;\r\n  export import PromptCachingBetaMessage = PromptCachingMessagesAPI.PromptCachingBetaMessage;\r\n  export import PromptCachingBetaMessageParam = PromptCachingMessagesAPI.PromptCachingBetaMessageParam;\r\n  export import PromptCachingBetaTextBlockParam = PromptCachingMessagesAPI.PromptCachingBetaTextBlockParam;\r\n  export import PromptCachingBetaTool = PromptCachingMessagesAPI.PromptCachingBetaTool;\r\n  export import PromptCachingBetaToolResultBlockParam = PromptCachingMessagesAPI.PromptCachingBetaToolResultBlockParam;\r\n  export import PromptCachingBetaToolUseBlockParam = PromptCachingMessagesAPI.PromptCachingBetaToolUseBlockParam;\r\n  export import PromptCachingBetaUsage = PromptCachingMessagesAPI.PromptCachingBetaUsage;\r\n  export import RawPromptCachingBetaMessageStartEvent = PromptCachingMessagesAPI.RawPromptCachingBetaMessageStartEvent;\r\n  export import RawPromptCachingBetaMessageStreamEvent = PromptCachingMessagesAPI.RawPromptCachingBetaMessageStreamEvent;\r\n  export import MessageCreateParams = PromptCachingMessagesAPI.MessageCreateParams;\r\n  export import MessageCreateParamsNonStreaming = PromptCachingMessagesAPI.MessageCreateParamsNonStreaming;\r\n  export import MessageCreateParamsStreaming = PromptCachingMessagesAPI.MessageCreateParamsStreaming;\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../../resource.js\";\r\nimport * as MessagesAPI from \"./messages.js\";\r\n\r\nexport class PromptCaching extends APIResource {\r\n  messages: MessagesAPI.Messages = new MessagesAPI.Messages(this._client);\r\n}\r\n\r\nexport namespace PromptCaching {\r\n  export import Messages = MessagesAPI.Messages;\r\n  export import PromptCachingBetaCacheControlEphemeral = MessagesAPI.PromptCachingBetaCacheControlEphemeral;\r\n  export import PromptCachingBetaImageBlockParam = MessagesAPI.PromptCachingBetaImageBlockParam;\r\n  export import PromptCachingBetaMessage = MessagesAPI.PromptCachingBetaMessage;\r\n  export import PromptCachingBetaMessageParam = MessagesAPI.PromptCachingBetaMessageParam;\r\n  export import PromptCachingBetaTextBlockParam = MessagesAPI.PromptCachingBetaTextBlockParam;\r\n  export import PromptCachingBetaTool = MessagesAPI.PromptCachingBetaTool;\r\n  export import PromptCachingBetaToolResultBlockParam = MessagesAPI.PromptCachingBetaToolResultBlockParam;\r\n  export import PromptCachingBetaToolUseBlockParam = MessagesAPI.PromptCachingBetaToolUseBlockParam;\r\n  export import PromptCachingBetaUsage = MessagesAPI.PromptCachingBetaUsage;\r\n  export import RawPromptCachingBetaMessageStartEvent = MessagesAPI.RawPromptCachingBetaMessageStartEvent;\r\n  export import RawPromptCachingBetaMessageStreamEvent = MessagesAPI.RawPromptCachingBetaMessageStreamEvent;\r\n  export import MessageCreateParams = MessagesAPI.MessageCreateParams;\r\n  export import MessageCreateParamsNonStreaming = MessagesAPI.MessageCreateParamsNonStreaming;\r\n  export import MessageCreateParamsStreaming = MessagesAPI.MessageCreateParamsStreaming;\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../../resource.js\";\r\nimport * as PromptCachingAPI from \"./prompt-caching/prompt-caching.js\";\r\n\r\nexport class Beta extends APIResource {\r\n  promptCaching: PromptCachingAPI.PromptCaching = new PromptCachingAPI.PromptCaching(this._client);\r\n}\r\n\r\nexport namespace Beta {\r\n  export import PromptCaching = PromptCachingAPI.PromptCaching;\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../resource.js\";\r\nimport { APIPromise } from \"../core.js\";\r\nimport * as Core from \"../core.js\";\r\nimport * as CompletionsAPI from \"./completions.js\";\r\nimport * as MessagesAPI from \"./messages.js\";\r\nimport { Stream } from \"../streaming.js\";\r\n\r\nexport class Completions extends APIResource {\r\n  /**\r\n   * [Legacy] Create a Text Completion.\r\n   *\r\n   * The Text Completions API is a legacy API. We recommend using the\r\n   * [Messages API](https://docs.anthropic.com/en/api/messages) going forward.\r\n   *\r\n   * Future models and features will not be compatible with Text Completions. See our\r\n   * [migration guide](https://docs.anthropic.com/en/api/migrating-from-text-completions-to-messages)\r\n   * for guidance in migrating from Text Completions to Messages.\r\n   */\r\n  create(body: CompletionCreateParamsNonStreaming, options?: Core.RequestOptions): APIPromise<Completion>;\r\n  create(\r\n    body: CompletionCreateParamsStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<Completion>>;\r\n  create(\r\n    body: CompletionCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<Completion> | Completion>;\r\n  create(\r\n    body: CompletionCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Completion> | APIPromise<Stream<Completion>> {\r\n    return this._client.post('/v1/complete', {\r\n      body,\r\n      timeout: (this._client as any)._options.timeout ?? 600000,\r\n      ...options,\r\n      stream: body.stream ?? false,\r\n    }) as APIPromise<Completion> | APIPromise<Stream<Completion>>;\r\n  }\r\n}\r\n\r\nexport interface Completion {\r\n  /**\r\n   * Unique object identifier.\r\n   *\r\n   * The format and length of IDs may change over time.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * The resulting completion up to and excluding the stop sequences.\r\n   */\r\n  completion: string;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * The reason that we stopped.\r\n   *\r\n   * This may be one the following values:\r\n   *\r\n   * - `\"stop_sequence\"`: we reached a stop sequence â€” either provided by you via the\r\n   *   `stop_sequences` parameter, or a stop sequence built into the model\r\n   * - `\"max_tokens\"`: we exceeded `max_tokens_to_sample` or the model's maximum\r\n   */\r\n  stop_reason: string | null;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Text Completions, this is always `\"completion\"`.\r\n   */\r\n  type: 'completion';\r\n}\r\n\r\nexport type CompletionCreateParams = CompletionCreateParamsNonStreaming | CompletionCreateParamsStreaming;\r\n\r\nexport interface CompletionCreateParamsBase {\r\n  /**\r\n   * The maximum number of tokens to generate before stopping.\r\n   *\r\n   * Note that our models may stop _before_ reaching this maximum. This parameter\r\n   * only specifies the absolute maximum number of tokens to generate.\r\n   */\r\n  max_tokens_to_sample: number;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: MessagesAPI.Model;\r\n\r\n  /**\r\n   * The prompt that you want Claude to complete.\r\n   *\r\n   * For proper response generation you will need to format your prompt using\r\n   * alternating `\\n\\nHuman:` and `\\n\\nAssistant:` conversational turns. For example:\r\n   *\r\n   * ```\r\n   * \"\\n\\nHuman: {userQuestion}\\n\\nAssistant:\"\r\n   * ```\r\n   *\r\n   * See [prompt validation](https://docs.anthropic.com/en/api/prompt-validation) and\r\n   * our guide to\r\n   * [prompt design](https://docs.anthropic.com/en/docs/intro-to-prompting) for more\r\n   * details.\r\n   */\r\n  prompt: string;\r\n\r\n  /**\r\n   * An object describing metadata about the request.\r\n   */\r\n  metadata?: CompletionCreateParams.Metadata;\r\n\r\n  /**\r\n   * Sequences that will cause the model to stop generating.\r\n   *\r\n   * Our models stop on `\"\\n\\nHuman:\"`, and may include additional built-in stop\r\n   * sequences in the future. By providing the stop_sequences parameter, you may\r\n   * include additional strings that will cause the model to stop generating.\r\n   */\r\n  stop_sequences?: Array<string>;\r\n\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.\r\n   */\r\n  stream?: boolean;\r\n\r\n  /**\r\n   * Amount of randomness injected into the response.\r\n   *\r\n   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`\r\n   * for analytical / multiple choice, and closer to `1.0` for creative and\r\n   * generative tasks.\r\n   *\r\n   * Note that even with `temperature` of `0.0`, the results will not be fully\r\n   * deterministic.\r\n   */\r\n  temperature?: number;\r\n\r\n  /**\r\n   * Only sample from the top K options for each subsequent token.\r\n   *\r\n   * Used to remove \"long tail\" low probability responses.\r\n   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_k?: number;\r\n\r\n  /**\r\n   * Use nucleus sampling.\r\n   *\r\n   * In nucleus sampling, we compute the cumulative distribution over all the options\r\n   * for each subsequent token in decreasing probability order and cut it off once it\r\n   * reaches a particular probability specified by `top_p`. You should either alter\r\n   * `temperature` or `top_p`, but not both.\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_p?: number;\r\n}\r\n\r\nexport namespace CompletionCreateParams {\r\n  /**\r\n   * An object describing metadata about the request.\r\n   */\r\n  export interface Metadata {\r\n    /**\r\n     * An external identifier for the user who is associated with the request.\r\n     *\r\n     * This should be a uuid, hash value, or other opaque identifier. Anthropic may use\r\n     * this id to help detect abuse. Do not include any identifying information such as\r\n     * name, email address, or phone number.\r\n     */\r\n    user_id?: string | null;\r\n  }\r\n\r\n  export type CompletionCreateParamsNonStreaming = CompletionsAPI.CompletionCreateParamsNonStreaming;\r\n  export type CompletionCreateParamsStreaming = CompletionsAPI.CompletionCreateParamsStreaming;\r\n}\r\n\r\nexport interface CompletionCreateParamsNonStreaming extends CompletionCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.\r\n   */\r\n  stream?: false;\r\n}\r\n\r\nexport interface CompletionCreateParamsStreaming extends CompletionCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/streaming) for details.\r\n   */\r\n  stream: true;\r\n}\r\n\r\nexport namespace Completions {\r\n  export import Completion = CompletionsAPI.Completion;\r\n  export import CompletionCreateParams = CompletionsAPI.CompletionCreateParams;\r\n  export import CompletionCreateParamsNonStreaming = CompletionsAPI.CompletionCreateParamsNonStreaming;\r\n  export import CompletionCreateParamsStreaming = CompletionsAPI.CompletionCreateParamsStreaming;\r\n}\r\n", "import * as Core from \"../core.js\";\r\nimport { AnthropicError, APIUserAbortError } from \"../error.js\";\r\nimport {\r\n  type ContentBlock,\r\n  Messages,\r\n  type Message,\r\n  type MessageStreamEvent,\r\n  type MessageParam,\r\n  type MessageCreateParams,\r\n  type MessageCreateParamsBase,\r\n  type TextBlock,\r\n} from \"../resources/messages.js\";\r\nimport { type ReadableStream } from \"../_shims/index.js\";\r\nimport { Stream } from \"../streaming.js\";\r\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.js\";\r\n\r\nexport interface MessageStreamEvents {\r\n  connect: () => void;\r\n  streamEvent: (event: MessageStreamEvent, snapshot: Message) => void;\r\n  text: (textDelta: string, textSnapshot: string) => void;\r\n  inputJson: (partialJson: string, jsonSnapshot: unknown) => void;\r\n  message: (message: Message) => void;\r\n  contentBlock: (content: ContentBlock) => void;\r\n  finalMessage: (message: Message) => void;\r\n  error: (error: AnthropicError) => void;\r\n  abort: (error: APIUserAbortError) => void;\r\n  end: () => void;\r\n}\r\n\r\ntype MessageStreamEventListeners<Event extends keyof MessageStreamEvents> = {\r\n  listener: MessageStreamEvents[Event];\r\n  once?: boolean;\r\n}[];\r\n\r\nconst JSON_BUF_PROPERTY = '__json_buf';\r\n\r\nexport class MessageStream implements AsyncIterable<MessageStreamEvent> {\r\n  messages: MessageParam[] = [];\r\n  receivedMessages: Message[] = [];\r\n  #currentMessageSnapshot: Message | undefined;\r\n\r\n  controller: AbortController = new AbortController();\r\n\r\n  #connectedPromise: Promise<void>;\r\n  #resolveConnectedPromise: () => void = () => {};\r\n  #rejectConnectedPromise: (error: AnthropicError) => void = () => {};\r\n\r\n  #endPromise: Promise<void>;\r\n  #resolveEndPromise: () => void = () => {};\r\n  #rejectEndPromise: (error: AnthropicError) => void = () => {};\r\n\r\n  #listeners: { [Event in keyof MessageStreamEvents]?: MessageStreamEventListeners<Event> } = {};\r\n\r\n  #ended = false;\r\n  #errored = false;\r\n  #aborted = false;\r\n  #catchingPromiseCreated = false;\r\n\r\n  constructor() {\r\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\r\n      this.#resolveConnectedPromise = resolve;\r\n      this.#rejectConnectedPromise = reject;\r\n    });\r\n\r\n    this.#endPromise = new Promise<void>((resolve, reject) => {\r\n      this.#resolveEndPromise = resolve;\r\n      this.#rejectEndPromise = reject;\r\n    });\r\n\r\n    // Don't let these promises cause unhandled rejection errors.\r\n    // we will manually cause an unhandled rejection error later\r\n    // if the user hasn't registered any error listener or called\r\n    // any promise-returning method.\r\n    this.#connectedPromise.catch(() => {});\r\n    this.#endPromise.catch(() => {});\r\n  }\r\n\r\n  /**\r\n   * Intended for use on the frontend, consuming a stream produced with\r\n   * `.toReadableStream()` on the backend.\r\n   *\r\n   * Note that messages sent to the model do not appear in `.on('message')`\r\n   * in this context.\r\n   */\r\n  static fromReadableStream(stream: ReadableStream): MessageStream {\r\n    const runner = new MessageStream();\r\n    runner._run(() => runner._fromReadableStream(stream));\r\n    return runner;\r\n  }\r\n\r\n  static createMessage(\r\n    messages: Messages,\r\n    params: MessageCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): MessageStream {\r\n    const runner = new MessageStream();\r\n    for (const message of params.messages) {\r\n      runner._addMessageParam(message);\r\n    }\r\n    runner._run(() =>\r\n      runner._createMessage(\r\n        messages,\r\n        { ...params, stream: true },\r\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\r\n      ),\r\n    );\r\n    return runner;\r\n  }\r\n\r\n  protected _run(executor: () => Promise<any>) {\r\n    executor().then(() => {\r\n      this._emitFinal();\r\n      this._emit('end');\r\n    }, this.#handleError);\r\n  }\r\n\r\n  protected _addMessageParam(message: MessageParam) {\r\n    this.messages.push(message);\r\n  }\r\n\r\n  protected _addMessage(message: Message, emit = true) {\r\n    this.receivedMessages.push(message);\r\n    if (emit) {\r\n      this._emit('message', message);\r\n    }\r\n  }\r\n\r\n  protected async _createMessage(\r\n    messages: Messages,\r\n    params: MessageCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<void> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n    const stream = await messages.create(\r\n      { ...params, stream: true },\r\n      { ...options, signal: this.controller.signal },\r\n    );\r\n    this._connected();\r\n    for await (const event of stream) {\r\n      this.#addStreamEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    this.#endRequest();\r\n  }\r\n\r\n  protected _connected() {\r\n    if (this.ended) return;\r\n    this.#resolveConnectedPromise();\r\n    this._emit('connect');\r\n  }\r\n\r\n  get ended(): boolean {\r\n    return this.#ended;\r\n  }\r\n\r\n  get errored(): boolean {\r\n    return this.#errored;\r\n  }\r\n\r\n  get aborted(): boolean {\r\n    return this.#aborted;\r\n  }\r\n\r\n  abort() {\r\n    this.controller.abort();\r\n  }\r\n\r\n  /**\r\n   * Adds the listener function to the end of the listeners array for the event.\r\n   * No checks are made to see if the listener has already been added. Multiple calls passing\r\n   * the same combination of event and listener will result in the listener being added, and\r\n   * called, multiple times.\r\n   * @returns this MessageStream, so that calls can be chained\r\n   */\r\n  on<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\r\n    const listeners: MessageStreamEventListeners<Event> =\r\n      this.#listeners[event] || (this.#listeners[event] = []);\r\n    listeners.push({ listener });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes the specified listener from the listener array for the event.\r\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\r\n   * listener has been added multiple times to the listener array for the specified event, then\r\n   * off() must be called multiple times to remove each instance.\r\n   * @returns this MessageStream, so that calls can be chained\r\n   */\r\n  off<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\r\n    const listeners = this.#listeners[event];\r\n    if (!listeners) return this;\r\n    const index = listeners.findIndex((l) => l.listener === listener);\r\n    if (index >= 0) listeners.splice(index, 1);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a one-time listener function for the event. The next time the event is triggered,\r\n   * this listener is removed and then invoked.\r\n   * @returns this MessageStream, so that calls can be chained\r\n   */\r\n  once<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\r\n    const listeners: MessageStreamEventListeners<Event> =\r\n      this.#listeners[event] || (this.#listeners[event] = []);\r\n    listeners.push({ listener, once: true });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\r\n   * the event is triggered, instead of calling a listener callback.\r\n   * @returns a Promise that resolves the next time given event is triggered,\r\n   * or rejects if an error is emitted.  (If you request the 'error' event,\r\n   * returns a promise that resolves with the error).\r\n   *\r\n   * Example:\r\n   *\r\n   *   const message = await stream.emitted('message') // rejects if the stream errors\r\n   */\r\n  emitted<Event extends keyof MessageStreamEvents>(\r\n    event: Event,\r\n  ): Promise<\r\n    Parameters<MessageStreamEvents[Event]> extends [infer Param] ? Param\r\n    : Parameters<MessageStreamEvents[Event]> extends [] ? void\r\n    : Parameters<MessageStreamEvents[Event]>\r\n  > {\r\n    return new Promise((resolve, reject) => {\r\n      this.#catchingPromiseCreated = true;\r\n      if (event !== 'error') this.once('error', reject);\r\n      this.once(event, resolve as any);\r\n    });\r\n  }\r\n\r\n  async done(): Promise<void> {\r\n    this.#catchingPromiseCreated = true;\r\n    await this.#endPromise;\r\n  }\r\n\r\n  get currentMessage(): Message | undefined {\r\n    return this.#currentMessageSnapshot;\r\n  }\r\n\r\n  #getFinalMessage(): Message {\r\n    if (this.receivedMessages.length === 0) {\r\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\r\n    }\r\n    return this.receivedMessages.at(-1)!;\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the the final assistant Message response,\r\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\r\n   */\r\n  async finalMessage(): Promise<Message> {\r\n    await this.done();\r\n    return this.#getFinalMessage();\r\n  }\r\n\r\n  #getFinalText(): string {\r\n    if (this.receivedMessages.length === 0) {\r\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\r\n    }\r\n    const textBlocks = this.receivedMessages\r\n      .at(-1)!\r\n      .content.filter((block): block is TextBlock => block.type === 'text')\r\n      .map((block) => block.text);\r\n    if (textBlocks.length === 0) {\r\n      throw new AnthropicError('stream ended without producing a content block with type=text');\r\n    }\r\n    return textBlocks.join(' ');\r\n  }\r\n\r\n  /**\r\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\r\n   * together if there are more than one text blocks.\r\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\r\n   */\r\n  async finalText(): Promise<string> {\r\n    await this.done();\r\n    return this.#getFinalText();\r\n  }\r\n\r\n  #handleError = (error: unknown) => {\r\n    this.#errored = true;\r\n    if (error instanceof Error && error.name === 'AbortError') {\r\n      error = new APIUserAbortError();\r\n    }\r\n    if (error instanceof APIUserAbortError) {\r\n      this.#aborted = true;\r\n      return this._emit('abort', error);\r\n    }\r\n    if (error instanceof AnthropicError) {\r\n      return this._emit('error', error);\r\n    }\r\n    if (error instanceof Error) {\r\n      const anthropicError: AnthropicError = new AnthropicError(error.message);\r\n      // @ts-ignore\r\n      anthropicError.cause = error;\r\n      return this._emit('error', anthropicError);\r\n    }\r\n    return this._emit('error', new AnthropicError(String(error)));\r\n  };\r\n\r\n  protected _emit<Event extends keyof MessageStreamEvents>(\r\n    event: Event,\r\n    ...args: Parameters<MessageStreamEvents[Event]>\r\n  ) {\r\n    // make sure we don't emit any MessageStreamEvents after end\r\n    if (this.#ended) return;\r\n\r\n    if (event === 'end') {\r\n      this.#ended = true;\r\n      this.#resolveEndPromise();\r\n    }\r\n\r\n    const listeners: MessageStreamEventListeners<Event> | undefined = this.#listeners[event];\r\n    if (listeners) {\r\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\r\n      listeners.forEach(({ listener }: any) => listener(...args));\r\n    }\r\n\r\n    if (event === 'abort') {\r\n      const error = args[0] as APIUserAbortError;\r\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\r\n        Promise.reject(error);\r\n      }\r\n      this.#rejectConnectedPromise(error);\r\n      this.#rejectEndPromise(error);\r\n      this._emit('end');\r\n      return;\r\n    }\r\n\r\n    if (event === 'error') {\r\n      // NOTE: _emit('error', error) should only be called from #handleError().\r\n\r\n      const error = args[0] as AnthropicError;\r\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\r\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\r\n        // If you are seeing stack traces here, make sure to handle errors via either:\r\n        // - runner.on('error', () => ...)\r\n        // - await runner.done()\r\n        // - await runner.final...()\r\n        // - etc.\r\n        Promise.reject(error);\r\n      }\r\n      this.#rejectConnectedPromise(error);\r\n      this.#rejectEndPromise(error);\r\n      this._emit('end');\r\n    }\r\n  }\r\n\r\n  protected _emitFinal() {\r\n    const finalMessage = this.receivedMessages.at(-1);\r\n    if (finalMessage) {\r\n      this._emit('finalMessage', this.#getFinalMessage());\r\n    }\r\n  }\r\n\r\n  #beginRequest() {\r\n    if (this.ended) return;\r\n    this.#currentMessageSnapshot = undefined;\r\n  }\r\n  #addStreamEvent(event: MessageStreamEvent) {\r\n    if (this.ended) return;\r\n    const messageSnapshot = this.#accumulateMessage(event);\r\n    this._emit('streamEvent', event, messageSnapshot);\r\n\r\n    switch (event.type) {\r\n      case 'content_block_delta': {\r\n        const content = messageSnapshot.content.at(-1)!;\r\n        if (event.delta.type === 'text_delta' && content.type === 'text') {\r\n          this._emit('text', event.delta.text, content.text || '');\r\n        } else if (event.delta.type === 'input_json_delta' && content.type === 'tool_use') {\r\n          if (content.input) {\r\n            this._emit('inputJson', event.delta.partial_json, content.input);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case 'message_stop': {\r\n        this._addMessageParam(messageSnapshot);\r\n        this._addMessage(messageSnapshot, true);\r\n        break;\r\n      }\r\n      case 'content_block_stop': {\r\n        this._emit('contentBlock', messageSnapshot.content.at(-1)!);\r\n        break;\r\n      }\r\n      case 'message_start': {\r\n        this.#currentMessageSnapshot = messageSnapshot;\r\n        break;\r\n      }\r\n      case 'content_block_start':\r\n      case 'message_delta':\r\n        break;\r\n    }\r\n  }\r\n  #endRequest(): Message {\r\n    if (this.ended) {\r\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\r\n    }\r\n    const snapshot = this.#currentMessageSnapshot;\r\n    if (!snapshot) {\r\n      throw new AnthropicError(`request ended without sending any chunks`);\r\n    }\r\n    this.#currentMessageSnapshot = undefined;\r\n    return snapshot;\r\n  }\r\n\r\n  protected async _fromReadableStream(\r\n    readableStream: ReadableStream,\r\n    options?: Core.RequestOptions,\r\n  ): Promise<void> {\r\n    const signal = options?.signal;\r\n    if (signal) {\r\n      if (signal.aborted) this.controller.abort();\r\n      signal.addEventListener('abort', () => this.controller.abort());\r\n    }\r\n    this.#beginRequest();\r\n    this._connected();\r\n    const stream = Stream.fromReadableStream<MessageStreamEvent>(readableStream, this.controller);\r\n    for await (const event of stream) {\r\n      this.#addStreamEvent(event);\r\n    }\r\n    if (stream.controller.signal?.aborted) {\r\n      throw new APIUserAbortError();\r\n    }\r\n    this.#endRequest();\r\n  }\r\n\r\n  /**\r\n   * Mutates this.#currentMessage with the current event. Handling the accumulation of multiple messages\r\n   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple\r\n   * messages.\r\n   */\r\n  #accumulateMessage(event: MessageStreamEvent): Message {\r\n    let snapshot = this.#currentMessageSnapshot;\r\n\r\n    if (event.type === 'message_start') {\r\n      if (snapshot) {\r\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\r\n      }\r\n      return event.message;\r\n    }\r\n\r\n    if (!snapshot) {\r\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\r\n    }\r\n\r\n    switch (event.type) {\r\n      case 'message_stop':\r\n        return snapshot;\r\n      case 'message_delta':\r\n        snapshot.stop_reason = event.delta.stop_reason;\r\n        snapshot.stop_sequence = event.delta.stop_sequence;\r\n        snapshot.usage.output_tokens = event.usage.output_tokens;\r\n        return snapshot;\r\n      case 'content_block_start':\r\n        snapshot.content.push(event.content_block);\r\n        return snapshot;\r\n      case 'content_block_delta': {\r\n        const snapshotContent = snapshot.content.at(event.index);\r\n        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {\r\n          snapshotContent.text += event.delta.text;\r\n        } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {\r\n          // we need to keep track of the raw JSON string as well so that we can\r\n          // re-parse it for each delta, for now we just store it as an untyped\r\n          // non-enumerable property on the snapshot\r\n          let jsonBuf = (snapshotContent as any)[JSON_BUF_PROPERTY] || '';\r\n          jsonBuf += event.delta.partial_json;\r\n\r\n          Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\r\n            value: jsonBuf,\r\n            enumerable: false,\r\n            writable: true,\r\n          });\r\n\r\n          if (jsonBuf) {\r\n            snapshotContent.input = partialParse(jsonBuf);\r\n          }\r\n        }\r\n        return snapshot;\r\n      }\r\n      case 'content_block_stop':\r\n        return snapshot;\r\n    }\r\n  }\r\n\r\n  [Symbol.asyncIterator](): AsyncIterator<MessageStreamEvent> {\r\n    const pushQueue: MessageStreamEvent[] = [];\r\n    const readQueue: {\r\n      resolve: (chunk: MessageStreamEvent | undefined) => void;\r\n      reject: (error: unknown) => void;\r\n    }[] = [];\r\n    let done = false;\r\n\r\n    this.on('streamEvent', (event) => {\r\n      const reader = readQueue.shift();\r\n      if (reader) {\r\n        reader.resolve(event);\r\n      } else {\r\n        pushQueue.push(event);\r\n      }\r\n    });\r\n\r\n    this.on('end', () => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.resolve(undefined);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('abort', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    this.on('error', (err) => {\r\n      done = true;\r\n      for (const reader of readQueue) {\r\n        reader.reject(err);\r\n      }\r\n      readQueue.length = 0;\r\n    });\r\n\r\n    return {\r\n      next: async (): Promise<IteratorResult<MessageStreamEvent>> => {\r\n        if (!pushQueue.length) {\r\n          if (done) {\r\n            return { value: undefined, done: true };\r\n          }\r\n          return new Promise<MessageStreamEvent | undefined>((resolve, reject) =>\r\n            readQueue.push({ resolve, reject }),\r\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\r\n        }\r\n        const chunk = pushQueue.shift()!;\r\n        return { value: chunk, done: false };\r\n      },\r\n      return: async () => {\r\n        this.abort();\r\n        return { value: undefined, done: true };\r\n      },\r\n    };\r\n  }\r\n\r\n  toReadableStream(): ReadableStream {\r\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\r\n    return stream.toReadableStream();\r\n  }\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport { APIResource } from \"../resource.js\";\r\nimport { APIPromise } from \"../core.js\";\r\nimport * as Core from \"../core.js\";\r\nimport * as MessagesAPI from \"./messages.js\";\r\nimport { Stream } from \"../streaming.js\";\r\nimport { MessageStream } from \"../lib/MessageStream.js\";\r\n\r\nexport { MessageStream } from \"../lib/MessageStream.js\";\r\n\r\nexport class Messages extends APIResource {\r\n  /**\r\n   * Create a Message.\r\n   *\r\n   * Send a structured list of input messages with text and/or image content, and the\r\n   * model will generate the next message in the conversation.\r\n   *\r\n   * The Messages API can be used for either single queries or stateless multi-turn\r\n   * conversations.\r\n   */\r\n  create(body: MessageCreateParamsNonStreaming, options?: Core.RequestOptions): APIPromise<Message>;\r\n  create(\r\n    body: MessageCreateParamsStreaming,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<RawMessageStreamEvent>>;\r\n  create(\r\n    body: MessageCreateParamsBase,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Stream<RawMessageStreamEvent> | Message>;\r\n  create(\r\n    body: MessageCreateParams,\r\n    options?: Core.RequestOptions,\r\n  ): APIPromise<Message> | APIPromise<Stream<RawMessageStreamEvent>> {\r\n    if (body.model in DEPRECATED_MODELS) {\r\n      console.warn(\r\n        `The model '${body.model}' is deprecated and will reach end-of-life on ${\r\n          DEPRECATED_MODELS[body.model]\r\n        }\\nPlease migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`,\r\n      );\r\n    }\r\n    return this._client.post('/v1/messages', {\r\n      body,\r\n      timeout: (this._client as any)._options.timeout ?? 600000,\r\n      ...options,\r\n      stream: body.stream ?? false,\r\n    }) as APIPromise<Message> | APIPromise<Stream<RawMessageStreamEvent>>;\r\n  }\r\n\r\n  /**\r\n   * Create a Message stream\r\n   */\r\n  stream(body: MessageStreamParams, options?: Core.RequestOptions): MessageStream {\r\n    return MessageStream.createMessage(this, body, options);\r\n  }\r\n}\r\n\r\nexport type ContentBlock = TextBlock | ToolUseBlock;\r\n\r\nexport type ContentBlockDeltaEvent = RawContentBlockDeltaEvent;\r\n\r\nexport type ContentBlockStartEvent = RawContentBlockStartEvent;\r\n\r\nexport type ContentBlockStopEvent = RawContentBlockStopEvent;\r\n\r\nexport interface ImageBlockParam {\r\n  source: ImageBlockParam.Source;\r\n\r\n  type: 'image';\r\n}\r\n\r\nexport namespace ImageBlockParam {\r\n  export interface Source {\r\n    data: string;\r\n\r\n    media_type: 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp';\r\n\r\n    type: 'base64';\r\n  }\r\n}\r\n\r\nexport type InputJsonDelta = InputJSONDelta;\r\n\r\nexport interface InputJSONDelta {\r\n  partial_json: string;\r\n\r\n  type: 'input_json_delta';\r\n}\r\n\r\nexport interface Message {\r\n  /**\r\n   * Unique object identifier.\r\n   *\r\n   * The format and length of IDs may change over time.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * Content generated by the model.\r\n   *\r\n   * This is an array of content blocks, each of which has a `type` that determines\r\n   * its shape.\r\n   *\r\n   * Example:\r\n   *\r\n   * ```json\r\n   * [{ \"type\": \"text\", \"text\": \"Hi, I'm Claude.\" }]\r\n   * ```\r\n   *\r\n   * If the request input `messages` ended with an `assistant` turn, then the\r\n   * response `content` will continue directly from that last turn. You can use this\r\n   * to constrain the model's output.\r\n   *\r\n   * For example, if the input `messages` were:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Then the response `content` might be:\r\n   *\r\n   * ```json\r\n   * [{ \"type\": \"text\", \"text\": \"B)\" }]\r\n   * ```\r\n   */\r\n  content: Array<ContentBlock>;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: Model;\r\n\r\n  /**\r\n   * Conversational role of the generated message.\r\n   *\r\n   * This will always be `\"assistant\"`.\r\n   */\r\n  role: 'assistant';\r\n\r\n  /**\r\n   * The reason that we stopped.\r\n   *\r\n   * This may be one the following values:\r\n   *\r\n   * - `\"end_turn\"`: the model reached a natural stopping point\r\n   * - `\"max_tokens\"`: we exceeded the requested `max_tokens` or the model's maximum\r\n   * - `\"stop_sequence\"`: one of your provided custom `stop_sequences` was generated\r\n   * - `\"tool_use\"`: the model invoked one or more tools\r\n   *\r\n   * In non-streaming mode this value is always non-null. In streaming mode, it is\r\n   * null in the `message_start` event and non-null otherwise.\r\n   */\r\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use' | null;\r\n\r\n  /**\r\n   * Which custom stop sequence was generated, if any.\r\n   *\r\n   * This value will be a non-null string if one of your custom stop sequences was\r\n   * generated.\r\n   */\r\n  stop_sequence: string | null;\r\n\r\n  /**\r\n   * Object type.\r\n   *\r\n   * For Messages, this is always `\"message\"`.\r\n   */\r\n  type: 'message';\r\n\r\n  /**\r\n   * Billing and rate-limit usage.\r\n   *\r\n   * Anthropic's API bills and rate-limits by token counts, as tokens represent the\r\n   * underlying cost to our systems.\r\n   *\r\n   * Under the hood, the API transforms requests into a format suitable for the\r\n   * model. The model's output then goes through a parsing stage before becoming an\r\n   * API response. As a result, the token counts in `usage` will not match one-to-one\r\n   * with the exact visible content of an API request or response.\r\n   *\r\n   * For example, `output_tokens` will be non-zero, even for an empty string response\r\n   * from Claude.\r\n   */\r\n  usage: Usage;\r\n}\r\n\r\nexport type MessageDeltaEvent = RawMessageDeltaEvent;\r\n\r\nexport interface MessageDeltaUsage {\r\n  /**\r\n   * The cumulative number of output tokens which were used.\r\n   */\r\n  output_tokens: number;\r\n}\r\n\r\nexport interface MessageParam {\r\n  content: string | Array<TextBlockParam | ImageBlockParam | ToolUseBlockParam | ToolResultBlockParam>;\r\n\r\n  role: 'user' | 'assistant';\r\n}\r\n\r\nexport type MessageStartEvent = RawMessageStartEvent;\r\n\r\nexport type MessageStopEvent = RawMessageStopEvent;\r\n\r\nexport type MessageStreamEvent = RawMessageStreamEvent;\r\n\r\n/**\r\n * The model that will complete your prompt.\\n\\nSee\r\n * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n * details and options.\r\n */\r\nexport type Model =\r\n  | (string & {})\r\n  | 'claude-3-5-sonnet-20240620'\r\n  | 'claude-3-opus-20240229'\r\n  | 'claude-3-sonnet-20240229'\r\n  | 'claude-3-haiku-20240307'\r\n  | 'claude-2.1'\r\n  | 'claude-2.0'\r\n  | 'claude-instant-1.2';\r\n\r\ntype DeprecatedModelsType = {\r\n  [K in Model]?: string;\r\n};\r\n\r\nconst DEPRECATED_MODELS: DeprecatedModelsType = {\r\n  'claude-1.3': 'November 6th, 2024',\r\n  'claude-1.3-100k': 'November 6th, 2024',\r\n  'claude-instant-1.1': 'November 6th, 2024',\r\n  'claude-instant-1.1-100k': 'November 6th, 2024',\r\n  'claude-instant-1.2': 'November 6th, 2024',\r\n};\r\n\r\nexport interface RawContentBlockDeltaEvent {\r\n  delta: TextDelta | InputJSONDelta;\r\n\r\n  index: number;\r\n\r\n  type: 'content_block_delta';\r\n}\r\n\r\nexport interface RawContentBlockStartEvent {\r\n  content_block: TextBlock | ToolUseBlock;\r\n\r\n  index: number;\r\n\r\n  type: 'content_block_start';\r\n}\r\n\r\nexport interface RawContentBlockStopEvent {\r\n  index: number;\r\n\r\n  type: 'content_block_stop';\r\n}\r\n\r\nexport interface RawMessageDeltaEvent {\r\n  delta: RawMessageDeltaEvent.Delta;\r\n\r\n  type: 'message_delta';\r\n\r\n  /**\r\n   * Billing and rate-limit usage.\r\n   *\r\n   * Anthropic's API bills and rate-limits by token counts, as tokens represent the\r\n   * underlying cost to our systems.\r\n   *\r\n   * Under the hood, the API transforms requests into a format suitable for the\r\n   * model. The model's output then goes through a parsing stage before becoming an\r\n   * API response. As a result, the token counts in `usage` will not match one-to-one\r\n   * with the exact visible content of an API request or response.\r\n   *\r\n   * For example, `output_tokens` will be non-zero, even for an empty string response\r\n   * from Claude.\r\n   */\r\n  usage: MessageDeltaUsage;\r\n}\r\n\r\nexport namespace RawMessageDeltaEvent {\r\n  export interface Delta {\r\n    stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use' | null;\r\n\r\n    stop_sequence: string | null;\r\n  }\r\n}\r\n\r\nexport interface RawMessageStartEvent {\r\n  message: Message;\r\n\r\n  type: 'message_start';\r\n}\r\n\r\nexport interface RawMessageStopEvent {\r\n  type: 'message_stop';\r\n}\r\n\r\nexport type RawMessageStreamEvent =\r\n  | RawMessageStartEvent\r\n  | RawMessageDeltaEvent\r\n  | RawMessageStopEvent\r\n  | RawContentBlockStartEvent\r\n  | RawContentBlockDeltaEvent\r\n  | RawContentBlockStopEvent;\r\n\r\nexport interface TextBlock {\r\n  text: string;\r\n\r\n  type: 'text';\r\n}\r\n\r\nexport interface TextBlockParam {\r\n  text: string;\r\n\r\n  type: 'text';\r\n}\r\n\r\nexport interface TextDelta {\r\n  text: string;\r\n\r\n  type: 'text_delta';\r\n}\r\n\r\nexport interface Tool {\r\n  /**\r\n   * [JSON schema](https://json-schema.org/) for this tool's input.\r\n   *\r\n   * This defines the shape of the `input` that your tool accepts and that the model\r\n   * will produce.\r\n   */\r\n  input_schema: Tool.InputSchema;\r\n\r\n  name: string;\r\n\r\n  /**\r\n   * Description of what this tool does.\r\n   *\r\n   * Tool descriptions should be as detailed as possible. The more information that\r\n   * the model has about what the tool is and how to use it, the better it will\r\n   * perform. You can use natural language descriptions to reinforce important\r\n   * aspects of the tool input JSON schema.\r\n   */\r\n  description?: string;\r\n}\r\n\r\nexport namespace Tool {\r\n  /**\r\n   * [JSON schema](https://json-schema.org/) for this tool's input.\r\n   *\r\n   * This defines the shape of the `input` that your tool accepts and that the model\r\n   * will produce.\r\n   */\r\n  export interface InputSchema {\r\n    type: 'object';\r\n\r\n    properties?: unknown | null;\r\n    [k: string]: unknown;\r\n  }\r\n}\r\n\r\nexport interface ToolResultBlockParam {\r\n  tool_use_id: string;\r\n\r\n  type: 'tool_result';\r\n\r\n  content?: string | Array<TextBlockParam | ImageBlockParam>;\r\n\r\n  is_error?: boolean;\r\n}\r\n\r\nexport interface ToolUseBlock {\r\n  id: string;\r\n\r\n  input: unknown;\r\n\r\n  name: string;\r\n\r\n  type: 'tool_use';\r\n}\r\n\r\nexport interface ToolUseBlockParam {\r\n  id: string;\r\n\r\n  input: unknown;\r\n\r\n  name: string;\r\n\r\n  type: 'tool_use';\r\n}\r\n\r\nexport interface Usage {\r\n  /**\r\n   * The number of input tokens which were used.\r\n   */\r\n  input_tokens: number;\r\n\r\n  /**\r\n   * The number of output tokens which were used.\r\n   */\r\n  output_tokens: number;\r\n}\r\n\r\nexport type MessageCreateParams = MessageCreateParamsNonStreaming | MessageCreateParamsStreaming;\r\n\r\nexport interface MessageCreateParamsBase {\r\n  /**\r\n   * The maximum number of tokens to generate before stopping.\r\n   *\r\n   * Note that our models may stop _before_ reaching this maximum. This parameter\r\n   * only specifies the absolute maximum number of tokens to generate.\r\n   *\r\n   * Different models have different maximum values for this parameter. See\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for details.\r\n   */\r\n  max_tokens: number;\r\n\r\n  /**\r\n   * Input messages.\r\n   *\r\n   * Our models are trained to operate on alternating `user` and `assistant`\r\n   * conversational turns. When creating a new `Message`, you specify the prior\r\n   * conversational turns with the `messages` parameter, and the model then generates\r\n   * the next `Message` in the conversation.\r\n   *\r\n   * Each input message must be an object with a `role` and `content`. You can\r\n   * specify a single `user`-role message, or you can include multiple `user` and\r\n   * `assistant` messages. The first message must always use the `user` role.\r\n   *\r\n   * If the final message uses the `assistant` role, the response content will\r\n   * continue immediately from the content in that message. This can be used to\r\n   * constrain part of the model's response.\r\n   *\r\n   * Example with a single `user` message:\r\n   *\r\n   * ```json\r\n   * [{ \"role\": \"user\", \"content\": \"Hello, Claude\" }]\r\n   * ```\r\n   *\r\n   * Example with multiple conversational turns:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   { \"role\": \"user\", \"content\": \"Hello there.\" },\r\n   *   { \"role\": \"assistant\", \"content\": \"Hi, I'm Claude. How can I help you?\" },\r\n   *   { \"role\": \"user\", \"content\": \"Can you explain LLMs in plain English?\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Example with a partially-filled response from Claude:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"role\": \"user\",\r\n   *     \"content\": \"What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun\"\r\n   *   },\r\n   *   { \"role\": \"assistant\", \"content\": \"The best answer is (\" }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Each input message `content` may be either a single `string` or an array of\r\n   * content blocks, where each block has a specific `type`. Using a `string` for\r\n   * `content` is shorthand for an array of one content block of type `\"text\"`. The\r\n   * following input messages are equivalent:\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": \"Hello, Claude\" }\r\n   * ```\r\n   *\r\n   * ```json\r\n   * { \"role\": \"user\", \"content\": [{ \"type\": \"text\", \"text\": \"Hello, Claude\" }] }\r\n   * ```\r\n   *\r\n   * Starting with Claude 3 models, you can also send image content blocks:\r\n   *\r\n   * ```json\r\n   * {\r\n   *   \"role\": \"user\",\r\n   *   \"content\": [\r\n   *     {\r\n   *       \"type\": \"image\",\r\n   *       \"source\": {\r\n   *         \"type\": \"base64\",\r\n   *         \"media_type\": \"image/jpeg\",\r\n   *         \"data\": \"/9j/4AAQSkZJRg...\"\r\n   *       }\r\n   *     },\r\n   *     { \"type\": \"text\", \"text\": \"What is in this image?\" }\r\n   *   ]\r\n   * }\r\n   * ```\r\n   *\r\n   * We currently support the `base64` source type for images, and the `image/jpeg`,\r\n   * `image/png`, `image/gif`, and `image/webp` media types.\r\n   *\r\n   * See [examples](https://docs.anthropic.com/en/api/messages-examples#vision) for\r\n   * more input examples.\r\n   *\r\n   * Note that if you want to include a\r\n   * [system prompt](https://docs.anthropic.com/en/docs/system-prompts), you can use\r\n   * the top-level `system` parameter â€” there is no `\"system\"` role for input\r\n   * messages in the Messages API.\r\n   */\r\n  messages: Array<MessageParam>;\r\n\r\n  /**\r\n   * The model that will complete your prompt.\\n\\nSee\r\n   * [models](https://docs.anthropic.com/en/docs/models-overview) for additional\r\n   * details and options.\r\n   */\r\n  model: Model;\r\n\r\n  /**\r\n   * An object describing metadata about the request.\r\n   */\r\n  metadata?: MessageCreateParams.Metadata;\r\n\r\n  /**\r\n   * Custom text sequences that will cause the model to stop generating.\r\n   *\r\n   * Our models will normally stop when they have naturally completed their turn,\r\n   * which will result in a response `stop_reason` of `\"end_turn\"`.\r\n   *\r\n   * If you want the model to stop generating when it encounters custom strings of\r\n   * text, you can use the `stop_sequences` parameter. If the model encounters one of\r\n   * the custom sequences, the response `stop_reason` value will be `\"stop_sequence\"`\r\n   * and the response `stop_sequence` value will contain the matched stop sequence.\r\n   */\r\n  stop_sequences?: Array<string>;\r\n\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream?: boolean;\r\n\r\n  /**\r\n   * System prompt.\r\n   *\r\n   * A system prompt is a way of providing context and instructions to Claude, such\r\n   * as specifying a particular goal or role. See our\r\n   * [guide to system prompts](https://docs.anthropic.com/en/docs/system-prompts).\r\n   */\r\n  system?: string | Array<TextBlockParam>;\r\n\r\n  /**\r\n   * Amount of randomness injected into the response.\r\n   *\r\n   * Defaults to `1.0`. Ranges from `0.0` to `1.0`. Use `temperature` closer to `0.0`\r\n   * for analytical / multiple choice, and closer to `1.0` for creative and\r\n   * generative tasks.\r\n   *\r\n   * Note that even with `temperature` of `0.0`, the results will not be fully\r\n   * deterministic.\r\n   */\r\n  temperature?: number;\r\n\r\n  /**\r\n   * How the model should use the provided tools. The model can use a specific tool,\r\n   * any available tool, or decide by itself.\r\n   */\r\n  tool_choice?:\r\n    | MessageCreateParams.ToolChoiceAuto\r\n    | MessageCreateParams.ToolChoiceAny\r\n    | MessageCreateParams.ToolChoiceTool;\r\n\r\n  /**\r\n   * Definitions of tools that the model may use.\r\n   *\r\n   * If you include `tools` in your API request, the model may return `tool_use`\r\n   * content blocks that represent the model's use of those tools. You can then run\r\n   * those tools using the tool input generated by the model and then optionally\r\n   * return results back to the model using `tool_result` content blocks.\r\n   *\r\n   * Each tool definition includes:\r\n   *\r\n   * - `name`: Name of the tool.\r\n   * - `description`: Optional, but strongly-recommended description of the tool.\r\n   * - `input_schema`: [JSON schema](https://json-schema.org/) for the tool `input`\r\n   *   shape that the model will produce in `tool_use` output content blocks.\r\n   *\r\n   * For example, if you defined `tools` as:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"description\": \"Get the current stock price for a given ticker symbol.\",\r\n   *     \"input_schema\": {\r\n   *       \"type\": \"object\",\r\n   *       \"properties\": {\r\n   *         \"ticker\": {\r\n   *           \"type\": \"string\",\r\n   *           \"description\": \"The stock ticker symbol, e.g. AAPL for Apple Inc.\"\r\n   *         }\r\n   *       },\r\n   *       \"required\": [\"ticker\"]\r\n   *     }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * And then asked the model \"What's the S&P 500 at today?\", the model might produce\r\n   * `tool_use` content blocks in the response like this:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_use\",\r\n   *     \"id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"name\": \"get_stock_price\",\r\n   *     \"input\": { \"ticker\": \"^GSPC\" }\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * You might then run your `get_stock_price` tool with `{\"ticker\": \"^GSPC\"}` as an\r\n   * input, and return the following back to the model in a subsequent `user`\r\n   * message:\r\n   *\r\n   * ```json\r\n   * [\r\n   *   {\r\n   *     \"type\": \"tool_result\",\r\n   *     \"tool_use_id\": \"toolu_01D7FLrfh4GYq7yT1ULFeyMV\",\r\n   *     \"content\": \"259.75 USD\"\r\n   *   }\r\n   * ]\r\n   * ```\r\n   *\r\n   * Tools can be used for workflows that include running client-side tools and\r\n   * functions, or more generally whenever you want the model to produce a particular\r\n   * JSON structure of output.\r\n   *\r\n   * See our [guide](https://docs.anthropic.com/en/docs/tool-use) for more details.\r\n   */\r\n  tools?: Array<Tool>;\r\n\r\n  /**\r\n   * Only sample from the top K options for each subsequent token.\r\n   *\r\n   * Used to remove \"long tail\" low probability responses.\r\n   * [Learn more technical details here](https://towardsdatascience.com/how-to-sample-from-language-models-682bceb97277).\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_k?: number;\r\n\r\n  /**\r\n   * Use nucleus sampling.\r\n   *\r\n   * In nucleus sampling, we compute the cumulative distribution over all the options\r\n   * for each subsequent token in decreasing probability order and cut it off once it\r\n   * reaches a particular probability specified by `top_p`. You should either alter\r\n   * `temperature` or `top_p`, but not both.\r\n   *\r\n   * Recommended for advanced use cases only. You usually only need to use\r\n   * `temperature`.\r\n   */\r\n  top_p?: number;\r\n}\r\n\r\nexport namespace MessageCreateParams {\r\n  /**\r\n   * An object describing metadata about the request.\r\n   */\r\n  export interface Metadata {\r\n    /**\r\n     * An external identifier for the user who is associated with the request.\r\n     *\r\n     * This should be a uuid, hash value, or other opaque identifier. Anthropic may use\r\n     * this id to help detect abuse. Do not include any identifying information such as\r\n     * name, email address, or phone number.\r\n     */\r\n    user_id?: string | null;\r\n  }\r\n\r\n  /**\r\n   * The model will automatically decide whether to use tools.\r\n   */\r\n  export interface ToolChoiceAuto {\r\n    type: 'auto';\r\n  }\r\n\r\n  /**\r\n   * The model will use any available tools.\r\n   */\r\n  export interface ToolChoiceAny {\r\n    type: 'any';\r\n  }\r\n\r\n  /**\r\n   * The model will use the specified tool with `tool_choice.name`.\r\n   */\r\n  export interface ToolChoiceTool {\r\n    /**\r\n     * The name of the tool to use.\r\n     */\r\n    name: string;\r\n\r\n    type: 'tool';\r\n  }\r\n\r\n  export type MessageCreateParamsNonStreaming = MessagesAPI.MessageCreateParamsNonStreaming;\r\n  export type MessageCreateParamsStreaming = MessagesAPI.MessageCreateParamsStreaming;\r\n}\r\n\r\nexport interface MessageCreateParamsNonStreaming extends MessageCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream?: false;\r\n}\r\n\r\nexport interface MessageCreateParamsStreaming extends MessageCreateParamsBase {\r\n  /**\r\n   * Whether to incrementally stream the response using server-sent events.\r\n   *\r\n   * See [streaming](https://docs.anthropic.com/en/api/messages-streaming) for\r\n   * details.\r\n   */\r\n  stream: true;\r\n}\r\n\r\nexport type MessageStreamParams = MessageCreateParamsBase;\r\n\r\nexport namespace Messages {\r\n  export import ContentBlock = MessagesAPI.ContentBlock;\r\n  export import ContentBlockDeltaEvent = MessagesAPI.ContentBlockDeltaEvent;\r\n  export import ContentBlockStartEvent = MessagesAPI.ContentBlockStartEvent;\r\n  export import ContentBlockStopEvent = MessagesAPI.ContentBlockStopEvent;\r\n  export import ImageBlockParam = MessagesAPI.ImageBlockParam;\r\n  export import InputJJsonDelta = MessagesAPI.InputJsonDelta;\r\n  export import InputJSONDelta = MessagesAPI.InputJSONDelta;\r\n  export import Message = MessagesAPI.Message;\r\n  export import MessageDeltaEvent = MessagesAPI.MessageDeltaEvent;\r\n  export import MessageDeltaUsage = MessagesAPI.MessageDeltaUsage;\r\n  export import MessageParam = MessagesAPI.MessageParam;\r\n  export import MessageStartEvent = MessagesAPI.MessageStartEvent;\r\n  export import MessageStopEvent = MessagesAPI.MessageStopEvent;\r\n  export import MessageStreamEvent = MessagesAPI.MessageStreamEvent;\r\n  export import Model = MessagesAPI.Model;\r\n  export import RawContentBlockDeltaEvent = MessagesAPI.RawContentBlockDeltaEvent;\r\n  export import RawContentBlockStartEvent = MessagesAPI.RawContentBlockStartEvent;\r\n  export import RawContentBlockStopEvent = MessagesAPI.RawContentBlockStopEvent;\r\n  export import RawMessageDeltaEvent = MessagesAPI.RawMessageDeltaEvent;\r\n  export import RawMessageStartEvent = MessagesAPI.RawMessageStartEvent;\r\n  export import RawMessageStopEvent = MessagesAPI.RawMessageStopEvent;\r\n  export import RawMessageStreamEvent = MessagesAPI.RawMessageStreamEvent;\r\n  export import TextBlock = MessagesAPI.TextBlock;\r\n  export import TextBlockParam = MessagesAPI.TextBlockParam;\r\n  export import TextDelta = MessagesAPI.TextDelta;\r\n  export import Tool = MessagesAPI.Tool;\r\n  export import ToolResultBlockParam = MessagesAPI.ToolResultBlockParam;\r\n  export import ToolUseBlock = MessagesAPI.ToolUseBlock;\r\n  export import ToolUseBlockParam = MessagesAPI.ToolUseBlockParam;\r\n  export import Usage = MessagesAPI.Usage;\r\n  export import MessageCreateParams = MessagesAPI.MessageCreateParams;\r\n  export import MessageCreateParamsNonStreaming = MessagesAPI.MessageCreateParamsNonStreaming;\r\n  export import MessageCreateParamsStreaming = MessagesAPI.MessageCreateParamsStreaming;\r\n  export import MessageStreamParams = MessagesAPI.MessageStreamParams;\r\n}\r\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\r\n\r\nimport * as Errors from \"./error.js\";\r\nimport * as Uploads from \"./uploads.js\";\r\nimport { type Agent } from \"./_shims/index.js\";\r\nimport * as Core from \"./core.js\";\r\nimport * as API from \"./resources/index.js\";\r\n\r\nexport interface ClientOptions {\r\n  /**\r\n   * Defaults to process.env['ANTHROPIC_API_KEY'].\r\n   */\r\n  apiKey?: string | null | undefined;\r\n\r\n  /**\r\n   * Defaults to process.env['ANTHROPIC_AUTH_TOKEN'].\r\n   */\r\n  authToken?: string | null | undefined;\r\n\r\n  /**\r\n   * Override the default base URL for the API, e.g., \"https://api.example.com/v2/\"\r\n   *\r\n   * Defaults to process.env['ANTHROPIC_BASE_URL'].\r\n   */\r\n  baseURL?: string | null | undefined;\r\n\r\n  /**\r\n   * The maximum amount of time (in milliseconds) that the client should wait for a response\r\n   * from the server before timing out a single request.\r\n   *\r\n   * Note that request timeouts are retried by default, so in a worst-case scenario you may wait\r\n   * much longer than this timeout before the promise succeeds or fails.\r\n   */\r\n  timeout?: number;\r\n\r\n  /**\r\n   * An HTTP agent used to manage HTTP(S) connections.\r\n   *\r\n   * If not provided, an agent will be constructed by default in the Node.js environment,\r\n   * otherwise no agent is used.\r\n   */\r\n  httpAgent?: Agent;\r\n\r\n  /**\r\n   * Specify a custom `fetch` function implementation.\r\n   *\r\n   * If not provided, we use `node-fetch` on Node.js and otherwise expect that `fetch` is\r\n   * defined globally.\r\n   */\r\n  fetch?: Core.Fetch | undefined;\r\n\r\n  /**\r\n   * The maximum number of times that the client will retry a request in case of a\r\n   * temporary failure, like a network error or a 5XX error from the server.\r\n   *\r\n   * @default 2\r\n   */\r\n  maxRetries?: number;\r\n\r\n  /**\r\n   * Default headers to include with every request to the API.\r\n   *\r\n   * These can be removed in individual requests by explicitly setting the\r\n   * header to `undefined` or `null` in request options.\r\n   */\r\n  defaultHeaders?: Core.Headers;\r\n\r\n  /**\r\n   * Default query parameters to include with every request to the API.\r\n   *\r\n   * These can be removed in individual requests by explicitly setting the\r\n   * param to `undefined` in request options.\r\n   */\r\n  defaultQuery?: Core.DefaultQuery;\r\n\r\n  /**\r\n   * By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\r\n   * Only set this option to `true` if you understand the risks and have appropriate mitigations in place.\r\n   */\r\n  dangerouslyAllowBrowser?: boolean;\r\n}\r\n\r\n/**\r\n * API Client for interfacing with the Anthropic API.\r\n */\r\nexport class Anthropic extends Core.APIClient {\r\n  apiKey: string | null;\r\n  authToken: string | null;\r\n\r\n  private _options: ClientOptions;\r\n\r\n  /**\r\n   * API Client for interfacing with the Anthropic API.\r\n   *\r\n   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]\r\n   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]\r\n   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.\r\n   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\r\n   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\r\n   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\r\n   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\r\n   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\r\n   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\r\n   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\r\n   */\r\n  constructor({\r\n    baseURL = Core.readEnv('ANTHROPIC_BASE_URL'),\r\n    apiKey = Core.readEnv('ANTHROPIC_API_KEY') ?? null,\r\n    authToken = Core.readEnv('ANTHROPIC_AUTH_TOKEN') ?? null,\r\n    ...opts\r\n  }: ClientOptions = {}) {\r\n    const options: ClientOptions = {\r\n      apiKey,\r\n      authToken,\r\n      ...opts,\r\n      baseURL: baseURL || `https://api.anthropic.com`,\r\n    };\r\n\r\n    if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\r\n      throw new Errors.AnthropicError(\r\n        \"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\\n\\nTODO: link!\\n\",\r\n      );\r\n    }\r\n\r\n    super({\r\n      baseURL: options.baseURL!,\r\n      timeout: options.timeout ?? 600000 /* 10 minutes */,\r\n      httpAgent: options.httpAgent,\r\n      maxRetries: options.maxRetries,\r\n      fetch: options.fetch,\r\n    });\r\n\r\n    this._options = options;\r\n\r\n    this.apiKey = apiKey;\r\n    this.authToken = authToken;\r\n  }\r\n\r\n  completions: API.Completions = new API.Completions(this);\r\n  messages: API.Messages = new API.Messages(this);\r\n  beta: API.Beta = new API.Beta(this);\r\n\r\n  protected override defaultQuery(): Core.DefaultQuery | undefined {\r\n    return this._options.defaultQuery;\r\n  }\r\n\r\n  protected override defaultHeaders(opts: Core.FinalRequestOptions): Core.Headers {\r\n    return {\r\n      ...super.defaultHeaders(opts),\r\n      ...(this._options.dangerouslyAllowBrowser ?\r\n        { 'anthropic-dangerous-direct-browser-access': 'true' }\r\n      : undefined),\r\n      'anthropic-version': '2023-06-01',\r\n      ...this._options.defaultHeaders,\r\n    };\r\n  }\r\n\r\n  protected override validateHeaders(headers: Core.Headers, customHeaders: Core.Headers) {\r\n    if (this.apiKey && headers['x-api-key']) {\r\n      return;\r\n    }\r\n    if (customHeaders['x-api-key'] === null) {\r\n      return;\r\n    }\r\n\r\n    if (this.authToken && headers['authorization']) {\r\n      return;\r\n    }\r\n    if (customHeaders['authorization'] === null) {\r\n      return;\r\n    }\r\n\r\n    throw new Error(\r\n      'Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the \"X-Api-Key\" or \"Authorization\" headers to be explicitly omitted',\r\n    );\r\n  }\r\n\r\n  protected override authHeaders(opts: Core.FinalRequestOptions): Core.Headers {\r\n    const apiKeyAuth = this.apiKeyAuth(opts);\r\n    const bearerAuth = this.bearerAuth(opts);\r\n\r\n    if (apiKeyAuth != null && !Core.isEmptyObj(apiKeyAuth)) {\r\n      return apiKeyAuth;\r\n    }\r\n\r\n    if (bearerAuth != null && !Core.isEmptyObj(bearerAuth)) {\r\n      return bearerAuth;\r\n    }\r\n    return {};\r\n  }\r\n\r\n  protected apiKeyAuth(opts: Core.FinalRequestOptions): Core.Headers {\r\n    if (this.apiKey == null) {\r\n      return {};\r\n    }\r\n    return { 'X-Api-Key': this.apiKey };\r\n  }\r\n\r\n  protected bearerAuth(opts: Core.FinalRequestOptions): Core.Headers {\r\n    if (this.authToken == null) {\r\n      return {};\r\n    }\r\n    return { Authorization: `Bearer ${this.authToken}` };\r\n  }\r\n\r\n  static Anthropic = this;\r\n  static HUMAN_PROMPT = '\\n\\nHuman:';\r\n  static AI_PROMPT = '\\n\\nAssistant:';\r\n  static DEFAULT_TIMEOUT = 600000; // 10 minutes\r\n\r\n  static AnthropicError = Errors.AnthropicError;\r\n  static APIError = Errors.APIError;\r\n  static APIConnectionError = Errors.APIConnectionError;\r\n  static APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\r\n  static APIUserAbortError = Errors.APIUserAbortError;\r\n  static NotFoundError = Errors.NotFoundError;\r\n  static ConflictError = Errors.ConflictError;\r\n  static RateLimitError = Errors.RateLimitError;\r\n  static BadRequestError = Errors.BadRequestError;\r\n  static AuthenticationError = Errors.AuthenticationError;\r\n  static InternalServerError = Errors.InternalServerError;\r\n  static PermissionDeniedError = Errors.PermissionDeniedError;\r\n  static UnprocessableEntityError = Errors.UnprocessableEntityError;\r\n\r\n  static toFile = Uploads.toFile;\r\n  static fileFromPath = Uploads.fileFromPath;\r\n}\r\n\r\nexport const { HUMAN_PROMPT, AI_PROMPT } = Anthropic;\r\n\r\nexport const {\r\n  AnthropicError,\r\n  APIError,\r\n  APIConnectionError,\r\n  APIConnectionTimeoutError,\r\n  APIUserAbortError,\r\n  NotFoundError,\r\n  ConflictError,\r\n  RateLimitError,\r\n  BadRequestError,\r\n  AuthenticationError,\r\n  InternalServerError,\r\n  PermissionDeniedError,\r\n  UnprocessableEntityError,\r\n} = Errors;\r\n\r\nexport import toFile = Uploads.toFile;\r\nexport import fileFromPath = Uploads.fileFromPath;\r\n\r\nexport namespace Anthropic {\r\n  export import RequestOptions = Core.RequestOptions;\r\n\r\n  export import Completions = API.Completions;\r\n  export import Completion = API.Completion;\r\n  export import CompletionCreateParams = API.CompletionCreateParams;\r\n  export import CompletionCreateParamsNonStreaming = API.CompletionCreateParamsNonStreaming;\r\n  export import CompletionCreateParamsStreaming = API.CompletionCreateParamsStreaming;\r\n\r\n  export import Messages = API.Messages;\r\n  export import ContentBlock = API.ContentBlock;\r\n  export import ContentBlockDeltaEvent = API.ContentBlockDeltaEvent;\r\n  export import ContentBlockStartEvent = API.ContentBlockStartEvent;\r\n  export import ContentBlockStopEvent = API.ContentBlockStopEvent;\r\n  export import ImageBlockParam = API.ImageBlockParam;\r\n  export import InputJSONDelta = API.InputJSONDelta;\r\n  export import Message = API.Message;\r\n  export import MessageDeltaEvent = API.MessageDeltaEvent;\r\n  export import MessageDeltaUsage = API.MessageDeltaUsage;\r\n  export import MessageParam = API.MessageParam;\r\n  export import MessageStartEvent = API.MessageStartEvent;\r\n  export import MessageStopEvent = API.MessageStopEvent;\r\n  export import MessageStreamEvent = API.MessageStreamEvent;\r\n  export import Model = API.Model;\r\n  export import RawContentBlockDeltaEvent = API.RawContentBlockDeltaEvent;\r\n  export import RawContentBlockStartEvent = API.RawContentBlockStartEvent;\r\n  export import RawContentBlockStopEvent = API.RawContentBlockStopEvent;\r\n  export import RawMessageDeltaEvent = API.RawMessageDeltaEvent;\r\n  export import RawMessageStartEvent = API.RawMessageStartEvent;\r\n  export import RawMessageStopEvent = API.RawMessageStopEvent;\r\n  export import RawMessageStreamEvent = API.RawMessageStreamEvent;\r\n  export import TextBlock = API.TextBlock;\r\n  export import TextBlockParam = API.TextBlockParam;\r\n  export import TextDelta = API.TextDelta;\r\n  export import Tool = API.Tool;\r\n  export import ToolResultBlockParam = API.ToolResultBlockParam;\r\n  export import ToolUseBlock = API.ToolUseBlock;\r\n  export import ToolUseBlockParam = API.ToolUseBlockParam;\r\n  export import Usage = API.Usage;\r\n  export import MessageCreateParams = API.MessageCreateParams;\r\n  export import MessageCreateParamsNonStreaming = API.MessageCreateParamsNonStreaming;\r\n  export import MessageCreateParamsStreaming = API.MessageCreateParamsStreaming;\r\n  export import MessageStreamParams = API.MessageStreamParams;\r\n\r\n  export import Beta = API.Beta;\r\n}\r\n\r\nexport default Anthropic;\r\n"],
  "mappings": "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",
  "names": ["fetch", "Request", "Response", "Headers", "FormData", "Blob", "File", "ReadableStream", "ReadableStream", "_a", "File", "_a", "fetch", "opts", "_a", "retryMessage", "_a", "_a", "_a", "__classPrivateFieldSet", "__classPrivateFieldGet", "_a", "_PromptCachingBetaMessageStream_getFinalMessage", "_PromptCachingBetaMessageStream_getFinalText", "_PromptCachingBetaMessageStream_beginRequest", "_PromptCachingBetaMessageStream_addStreamEvent", "_PromptCachingBetaMessageStream_endRequest", "_PromptCachingBetaMessageStream_accumulateMessage", "chunk", "Messages", "PromptCaching", "Beta", "Completions", "JSON_BUF_PROPERTY", "__classPrivateFieldSet", "__classPrivateFieldGet", "_a", "_MessageStream_getFinalMessage", "_MessageStream_getFinalText", "_MessageStream_beginRequest", "_MessageStream_addStreamEvent", "_MessageStream_endRequest", "_MessageStream_accumulateMessage", "chunk", "Messages", "Messages", "AnthropicError", "APIError", "APIConnectionError", "APIConnectionTimeoutError", "APIUserAbortError", "NotFoundError", "ConflictError", "RateLimitError", "BadRequestError", "AuthenticationError", "InternalServerError", "PermissionDeniedError", "UnprocessableEntityError", "toFile", "fileFromPath", "Anthropic"]
}
